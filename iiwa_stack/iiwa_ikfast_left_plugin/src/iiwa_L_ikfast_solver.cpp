/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2019-08-01 13:39:27.731982
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65,x66,x67,x68,x69,x70,x71,x72,x73,x74;
x0=IKcos(j[0]);
x1=IKcos(j[1]);
x2=IKcos(j[2]);
x3=IKsin(j[0]);
x4=IKsin(j[2]);
x5=IKcos(j[3]);
x6=IKsin(j[1]);
x7=IKsin(j[3]);
x8=IKcos(j[4]);
x9=IKsin(j[4]);
x10=IKcos(j[6]);
x11=IKsin(j[6]);
x12=IKsin(j[5]);
x13=IKcos(j[5]);
x14=((0.4)*x3);
x15=((0.496)*x6);
x16=((1.0)*x5);
x17=((0.03)*x8);
x18=((1.0)*x8);
x19=((1.0)*x0);
x20=((0.496)*x7);
x21=((0.03)*x9);
x22=((1.0)*x4);
x23=((1.0)*x1);
x24=((1.0)*x13);
x25=((0.4)*x6);
x26=((1.0)*x9);
x27=((0.4)*x0);
x28=((0.496)*x8);
x29=(x2*x7);
x30=(x5*x6);
x31=((-0.03)*x13);
x32=((-0.03)*x12);
x33=(x6*x7);
x34=(x0*x4);
x35=((-1.0)*x9);
x36=(x2*x3);
x37=((-1.0)*x8);
x38=(x1*x5);
x39=(x1*x2);
x40=(x4*x6);
x41=(x22*x3);
x42=(x16*x2*x6);
x43=(x22*x6*x9);
x44=((((-1.0)*x41))+((x0*x39)));
x45=(x34+((x1*x36)));
x46=(((x29*x6))+x38);
x47=((((-1.0)*x42))+((x1*x7)));
x48=((((-1.0)*x19*x39))+x41);
x49=((((-1.0)*x19*x2))+((x1*x41)));
x50=(x42+(((-1.0)*x23*x7)));
x51=(((x1*x19*x4))+(((1.0)*x36)));
x52=((((-1.0)*x19*x4))+(((-1.0)*x23*x36)));
x53=(x12*x46);
x54=(x44*x5);
x55=(x50*x8);
x56=(x49*x8);
x57=(x49*x9);
x58=(x51*x9);
x59=(x52*x7);
x60=(x54+((x0*x33)));
x61=(((x3*x33))+((x45*x5)));
x62=(((x48*x7))+((x0*x30)));
x63=((((-1.0)*x43))+x55);
x64=(((x18*x40))+(((-1.0)*x26*x47)));
x65=((((-1.0)*x19*x33))+(((-1.0)*x16*x44)));
x66=(((x3*x30))+x59);
x67=((((-1.0)*x3*x33))+(((-1.0)*x16*x45)));
x68=(x13*x63);
x69=(x12*x62);
x70=(x67*x8);
x71=(x65*x8);
x72=(x12*x66);
x73=(x70+x57);
x74=(x71+x58);
eerot[0]=((((-1.0)*x10*(((((1.0)*x69))+(((1.0)*x13*((x58+((x8*(((((-1.0)*x0*x33))+(((-1.0)*x54))))))))))))))+((x11*(((((-1.0)*x18*x51))+(((-1.0)*x26*x60)))))));
eerot[1]=(((x10*((((x37*x51))+((x35*x60))))))+((x11*((x69+((x13*x74)))))));
eerot[2]=(((x13*x62))+((x12*(((((-1.0)*x18*x65))+(((-1.0)*x26*x51)))))));
IkReal x75=(x0*x5);
eetrans[0]=(((x0*x25))+((x12*(((((-1.0)*x28*x65))+(((-0.496)*x58))))))+((x10*((((x32*x62))+((x31*x74))))))+((x11*(((((-0.03)*x60*x9))+(((-0.03)*x51*x8))))))+((x25*x75))+((x13*((((x20*x48))+((x15*x75))))))+((x7*(((((-1.0)*x27*x39))+((x14*x4)))))));
eerot[3]=(((x10*(((((-1.0)*x72))+(((-1.0)*x24*x73))))))+((x11*((((x37*x49))+((x35*x61)))))));
eerot[4]=(((x10*(((((-1.0)*x18*x49))+(((-1.0)*x26*x61))))))+((x11*((x72+((x13*x73)))))));
eerot[5]=(((x13*x66))+((x12*(((((-1.0)*x18*x67))+(((-1.0)*x26*x49)))))));
eetrans[1]=(((x12*(((((-0.496)*x57))+(((-0.496)*x70))))))+((x13*((((x20*x52))+((x15*x3*x5))))))+((x14*x6))+((x14*x30))+((x7*(((((-1.0)*x14*x39))+(((-1.0)*x27*x4))))))+((x10*((((x32*x66))+((x31*x73))))))+((x11*(((((-1.0)*x17*x49))+(((-1.0)*x21*x61)))))));
eerot[6]=(((x10*(((((-1.0)*x24*x63))+(((-1.0)*x53))))))+((x11*x64)));
eerot[7]=(((x10*x64))+((x11*((x53+x68)))));
eerot[8]=(((x12*(((((-1.0)*x18*x50))+x43))))+((x13*x46)));
eetrans[2]=((0.34)+((x12*(((((-1.0)*x28*x50))+((x15*x4*x9))))))+((x13*(((((0.496)*x38))+((x15*x29))))))+((x11*((((x17*x40))+(((-1.0)*x21*x47))))))+(((0.4)*x1))+(((0.4)*x38))+((x25*x29))+((x10*((((x32*x46))+((x31*((((x35*x40))+x55)))))))));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j2,cj2,sj2,htj2,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij2[2], _nj2;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij2[0] = -1; _ij2[1] = -1; _nj2 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j2=pfree[0]; cj2=cos(pfree[0]); sj2=sin(pfree[0]), htj2=tan(pfree[0]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*r00);
new_r01=((-1.0)*r01);
new_r02=r02;
new_px=((((-0.496)*r02))+px+(((-0.03)*r00)));
new_r10=((-1.0)*r10);
new_r11=((-1.0)*r11);
new_r12=r12;
new_py=((((-0.496)*r12))+py+(((-0.03)*r10)));
new_r20=((-1.0)*r20);
new_r21=((-1.0)*r21);
new_r22=r22;
new_pz=((-0.34)+(((-0.496)*r22))+(((-0.03)*r20))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x76=((1.0)*px);
IkReal x77=((1.0)*pz);
IkReal x78=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x78))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x77)));
rxp0_2=((((-1.0)*r10*x76))+((py*r00)));
rxp1_0=((((-1.0)*r21*x78))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x77)));
rxp1_2=(((py*r01))+(((-1.0)*r11*x76)));
rxp2_0=((((-1.0)*r22*x78))+((pz*r12)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x77)));
rxp2_2=(((py*r02))+(((-1.0)*r12*x76)));
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
cj3array[0]=((-1.0)+(((3.125)*pp)));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
IkReal j0eval[2];
j0eval[0]=((px*px)+(py*py));
j0eval[1]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
j1eval[0]=((IKabs((cj2*sj3)))+(((2.5)*(IKabs(((-0.4)+(((-0.4)*cj3))))))));
j1eval[1]=((1.0)+(cj3*cj3)+(((2.0)*cj3))+(((cj2*cj2)*(sj3*sj3))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x79=cj2*cj2;
IkReal x80=sj2*sj2;
IkReal x81=px*px;
IkReal x82=py*py;
IkReal x83=py*py*py*py;
IkReal x84=sj2*sj2*sj2*sj2;
IkReal x85=cj2*cj2*cj2*cj2;
IkReal x86=(px*py);
IkReal x87=((1.0)*x82);
IkReal x88=(x81*x82);
IkReal x89=((2.0)*x79*x80);
j0eval[0]=(((x84*x88))+((x85*x88))+((x88*x89))+((x83*x84))+((x83*x89))+((x83*x85)));
j0eval[1]=((IKabs((((x79*x86))+((x80*x86)))))+(IKabs(((((-1.0)*x80*x87))+(((-1.0)*x79*x87))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x90=sj2*sj2;
IkReal x91=cj2*cj2;
IkReal x92=py*py;
IkReal x93=(px*py);
IkReal x94=((1.0)*x92);
j0eval[0]=((IKabs((((x90*x93))+((x91*x93)))))+(IKabs(((((-1.0)*x90*x94))+(((-1.0)*x91*x94))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x95=px*px;
IkReal x96=cj2*cj2;
IkReal x97=sj2*sj2;
IkReal x98=((1.0)*px*py);
j0eval[0]=((IKabs(((((-1.0)*x96*x98))+(((-1.0)*x97*x98)))))+(IKabs((((x95*x97))+((x95*x96))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(px);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
IkReal x99=((-1.0)*pz);
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
px=0;
pp=((py*py)+(pz*pz));
npx=(((py*r10))+((pz*r20)));
npy=(((py*r11))+((pz*r21)));
npz=(((py*r12))+((pz*r22)));
rxp0_1=(r00*x99);
rxp0_2=(py*r00);
rxp1_1=(r01*x99);
rxp1_2=(py*r01);
rxp2_1=(r02*x99);
rxp2_2=(py*r02);
j0eval[0]=IKabs(py);
if( IKabs(j0eval[0]) < 0.0000000100000000  )
{
{
IkReal j0eval[1];
IkReal x100=((-1.0)*pz);
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
px=0;
pp=((py*py)+(pz*pz));
npx=(((py*r10))+((pz*r20)));
npy=(((py*r11))+((pz*r21)));
npz=(((py*r12))+((pz*r22)));
rxp0_1=(r00*x100);
rxp0_2=(py*r00);
rxp1_1=(r01*x100);
rxp1_2=(py*r01);
rxp2_1=(r02*x100);
rxp2_2=(py*r02);
IkReal x101=py*py;
j0eval[0]=IKabs((((x101*(cj2*cj2)))+((x101*(sj2*sj2)))));
if( IKabs(j0eval[0]) < 0.0000000100000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(py);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1027=py*py;
IkReal x1028=sj2*sj2;
IkReal x1029=cj2*cj2;
IkReal x1030=(x1027*x1029);
IkReal x1031=(x1027*x1028);
op[0]=(x1030+x1031);
op[1]=0;
op[2]=((((-1.0)*x1030))+(((-1.0)*x1031)));
polyroots2(op,zeror,numroots);
IkReal j0array[2], cj0array[2], sj0array[2], tempj0array[1];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ++ij0)
{
IkReal htj0 = zeror[ij0];
tempj0array[0]=((2.0)*(atan(htj0)));
for(int kj0 = 0; kj0 < 1; ++kj0)
{
j0array[numsolutions] = tempj0array[kj0];
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
numsolutions++;
}
}
bool j0valid[2]={true,true};
_nj0 = 2;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
htj0 = IKtan(j0/2);

_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
{
IkReal j1eval[2];
IkReal x1032=((-1.0)*pz);
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
px=0;
pp=((py*py)+(pz*pz));
npx=(((py*r10))+((pz*r20)));
npy=(((py*r11))+((pz*r21)));
npz=(((py*r12))+((pz*r22)));
rxp0_1=(r00*x1032);
rxp0_2=(py*r00);
rxp1_1=(r01*x1032);
rxp1_2=(py*r01);
rxp2_1=(r02*x1032);
rxp2_2=(py*r02);
j1eval[0]=sj0;
j1eval[1]=sj2;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x1033=((-1.0)*pz);
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
px=0;
pp=((py*py)+(pz*pz));
npx=(((py*r10))+((pz*r20)));
npy=(((py*r11))+((pz*r21)));
npz=(((py*r12))+((pz*r22)));
rxp0_1=(r00*x1033);
rxp0_2=(py*r00);
rxp1_1=(r01*x1033);
rxp1_2=(py*r01);
rxp2_1=(r02*x1033);
rxp2_2=(py*r02);
j1eval[0]=cj2;
j1eval[1]=sj0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x1034=IKPowWithIntegerCheck(cj2,-1);
if(!x1034.valid){
continue;
}
CheckValue<IkReal> x1035=IKPowWithIntegerCheck(sj0,-1);
if(!x1035.valid){
continue;
}
cj1array[0]=((-1.0)*cj0*sj2*(x1034.value)*(x1035.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[3];
IkReal x1036=IKsin(j1);
IkReal x1037=(py*sj0);
evalcond[0]=((0.8)*x1036*x1037);
evalcond[1]=((-1.0)*x1036*x1037);
evalcond[2]=((((-1.0)*sj2*x1037*(IKcos(j1))))+((cj0*cj2*py)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x1038=IKPowWithIntegerCheck(sj0,-1);
if(!x1038.valid){
continue;
}
CheckValue<IkReal> x1039=IKPowWithIntegerCheck(sj2,-1);
if(!x1039.valid){
continue;
}
cj1array[0]=(cj0*cj2*(x1038.value)*(x1039.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[3];
IkReal x1040=IKsin(j1);
IkReal x1041=((1.0)*py);
IkReal x1042=(py*sj0*x1040);
evalcond[0]=((0.8)*x1042);
evalcond[1]=((-1.0)*x1042);
evalcond[2]=((((-1.0)*cj2*sj0*x1041*(IKcos(j1))))+(((-1.0)*cj0*sj2*x1041)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
    }

}

}

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=py;
op[1]=0;
op[2]=((-1.0)*py);
polyroots2(op,zeror,numroots);
IkReal j0array[2], cj0array[2], sj0array[2], tempj0array[1];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ++ij0)
{
IkReal htj0 = zeror[ij0];
tempj0array[0]=((2.0)*(atan(htj0)));
for(int kj0 = 0; kj0 < 1; ++kj0)
{
j0array[numsolutions] = tempj0array[kj0];
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
numsolutions++;
}
}
bool j0valid[2]={true,true};
_nj0 = 2;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
htj0 = IKtan(j0/2);

_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
{
IkReal j1eval[2];
IkReal x1043=((-1.0)*pz);
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
px=0;
pp=((py*py)+(pz*pz));
npx=(((py*r10))+((pz*r20)));
npy=(((py*r11))+((pz*r21)));
npz=(((py*r12))+((pz*r22)));
rxp0_1=(r00*x1043);
rxp0_2=(py*r00);
rxp1_1=(r01*x1043);
rxp1_2=(py*r01);
rxp2_1=(r02*x1043);
rxp2_2=(py*r02);
j1eval[0]=sj0;
j1eval[1]=sj2;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x1044=((-1.0)*pz);
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
px=0;
pp=((py*py)+(pz*pz));
npx=(((py*r10))+((pz*r20)));
npy=(((py*r11))+((pz*r21)));
npz=(((py*r12))+((pz*r22)));
rxp0_1=(r00*x1044);
rxp0_2=(py*r00);
rxp1_1=(r01*x1044);
rxp1_2=(py*r01);
rxp2_1=(r02*x1044);
rxp2_2=(py*r02);
j1eval[0]=cj2;
j1eval[1]=sj0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x1045=IKPowWithIntegerCheck(cj2,-1);
if(!x1045.valid){
continue;
}
CheckValue<IkReal> x1046=IKPowWithIntegerCheck(sj0,-1);
if(!x1046.valid){
continue;
}
cj1array[0]=((-1.0)*cj0*sj2*(x1045.value)*(x1046.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[3];
IkReal x1047=IKsin(j1);
IkReal x1048=(py*sj0);
evalcond[0]=((0.8)*x1047*x1048);
evalcond[1]=((-1.0)*x1047*x1048);
evalcond[2]=((((-1.0)*sj2*x1048*(IKcos(j1))))+((cj0*cj2*py)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x1049=IKPowWithIntegerCheck(sj0,-1);
if(!x1049.valid){
continue;
}
CheckValue<IkReal> x1050=IKPowWithIntegerCheck(sj2,-1);
if(!x1050.valid){
continue;
}
cj1array[0]=(cj0*cj2*(x1049.value)*(x1050.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[3];
IkReal x1051=IKsin(j1);
IkReal x1052=((1.0)*py);
IkReal x1053=(py*sj0*x1051);
evalcond[0]=((0.8)*x1053);
evalcond[1]=((-1.0)*x1053);
evalcond[2]=((((-1.0)*cj0*sj2*x1052))+(((-1.0)*cj2*sj0*x1052*(IKcos(j1)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x1054=sj2*sj2;
IkReal x1055=cj2*cj2;
IkReal x1056=px*px;
IkReal x1057=((1.0)*px*py);
CheckValue<IkReal> x1059 = IKatan2WithCheck(IkReal(((((-1.0)*x1054*x1057))+(((-1.0)*x1055*x1057)))),IkReal((((x1054*x1056))+((x1055*x1056)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1059.valid){
continue;
}
IkReal x1058=x1059.value;
j0array[0]=((-1.0)*x1058);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1058)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x1060=sj2*sj2;
IkReal x1061=cj2*cj2;
IkReal x1062=py*py;
IkReal x1063=IKsin(j0);
IkReal x1064=IKcos(j0);
IkReal x1065=(px*py);
IkReal x1066=((1.0)*x1064);
IkReal x1067=((1.0)*x1062);
evalcond[0]=(((x1063*((((x1061*x1065))+((x1060*x1065))))))+((x1064*(((((-1.0)*x1060*x1067))+(((-1.0)*x1061*x1067)))))));
evalcond[1]=((((-1.0)*py*x1066))+((px*x1063)));
evalcond[2]=((((-1.0)*px*x1066))+(((-1.0)*py*x1063)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x1068=((1.0)*sj2);
j1eval[0]=((((-1.0)*py*sj0*x1068))+(((-1.0)*cj0*px*x1068)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x1069=((1.0)*cj2);
j1eval[0]=((((-1.0)*py*sj0*x1069))+(((-1.0)*cj0*px*x1069)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j1eval[0]=IKabs((((cj0*px))+((py*sj0))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(px)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1070=(cj0*px);
IkReal x1071=(py*sj0);
op[0]=(x1070+x1071);
op[1]=0;
op[2]=((((-1.0)*x1070))+(((-1.0)*x1071)));
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
j1eval[0]=IKabs(((((-1.0)*py*sj0))+(((-1.0)*cj0*px))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(px)));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1072=(cj0*px);
IkReal x1073=(py*sj0);
op[0]=((((-1.0)*x1072))+(((-1.0)*x1073)));
op[1]=0;
op[2]=(x1072+x1073);
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj2=0;
cj2=1.0;
j2=0;
j1eval[0]=IKabs((((cj0*px))+((py*sj0))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(px)));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1074=(cj0*px);
IkReal x1075=(py*sj0);
op[0]=(x1074+x1075);
op[1]=0;
op[2]=((((-1.0)*x1075))+(((-1.0)*x1074)));
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j1eval[0]=IKabs(((((-1.0)*py*sj0))+(((-1.0)*cj0*px))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(px)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1076=(cj0*px);
IkReal x1077=(py*sj0);
op[0]=((((-1.0)*x1076))+(((-1.0)*x1077)));
op[1]=0;
op[2]=(x1076+x1077);
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(px)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x1078=((1.0)*px);
CheckValue<IkReal> x1081=IKPowWithIntegerCheck(((((-1.0)*cj0*cj2*x1078))+(((-1.0)*cj2*py*sj0))),-1);
if(!x1081.valid){
continue;
}
IkReal x1079=x1081.value;
IkReal x1080=(sj2*x1079);
CheckValue<IkReal> x1082=IKPowWithIntegerCheck(((((-1.0)*cj0*cj2*px))+(((-1.0)*cj2*py*sj0))),-1);
if(!x1082.valid){
continue;
}
cj1array[0]=((((-1.0)*sj0*sj2*x1078*(x1082.value)))+((cj0*py*x1080)));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[3];
IkReal x1083=IKsin(j1);
IkReal x1084=IKcos(j1);
IkReal x1085=((1.0)*px);
IkReal x1086=(sj2*x1084);
IkReal x1087=(cj0*px*x1083);
IkReal x1088=(py*sj0*x1083);
evalcond[0]=((((0.8)*x1087))+(((0.8)*x1088)));
evalcond[1]=((((-1.0)*x1088))+(((-1.0)*cj0*x1083*x1085)));
evalcond[2]=((((-1.0)*cj2*sj0*x1085))+(((-1.0)*cj0*x1085*x1086))+(((-1.0)*py*sj0*x1086))+((cj0*cj2*py)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x1089=((1.0)*cj0);
CheckValue<IkReal> x1092=IKPowWithIntegerCheck(((((-1.0)*py*sj0*sj2))+(((-1.0)*px*sj2*x1089))),-1);
if(!x1092.valid){
continue;
}
IkReal x1090=x1092.value;
IkReal x1091=(cj2*x1090);
CheckValue<IkReal> x1093=IKPowWithIntegerCheck(((((-1.0)*cj0*px*sj2))+(((-1.0)*py*sj0*sj2))),-1);
if(!x1093.valid){
continue;
}
cj1array[0]=(((px*sj0*x1091))+(((-1.0)*cj2*py*x1089*(x1093.value))));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[3];
IkReal x1094=IKsin(j1);
IkReal x1095=IKcos(j1);
IkReal x1096=((1.0)*py);
IkReal x1097=(sj0*x1094);
IkReal x1098=(cj2*x1095);
IkReal x1099=(cj0*px*x1094);
evalcond[0]=((((0.8)*x1099))+(((0.8)*py*x1097)));
evalcond[1]=((((-1.0)*x1096*x1097))+(((-1.0)*x1099)));
evalcond[2]=(((px*sj0*sj2))+(((-1.0)*sj0*x1096*x1098))+(((-1.0)*cj0*px*x1098))+(((-1.0)*cj0*sj2*x1096)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x1100=py*py;
IkReal x1101=sj2*sj2;
IkReal x1102=cj2*cj2;
IkReal x1103=(px*py);
IkReal x1104=((1.0)*x1100);
CheckValue<IkReal> x1106 = IKatan2WithCheck(IkReal(((((-1.0)*x1102*x1104))+(((-1.0)*x1101*x1104)))),IkReal((((x1102*x1103))+((x1101*x1103)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1106.valid){
continue;
}
IkReal x1105=x1106.value;
j0array[0]=((-1.0)*x1105);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1105)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x1107=px*px;
IkReal x1108=cj2*cj2;
IkReal x1109=sj2*sj2;
IkReal x1110=IKsin(j0);
IkReal x1111=IKcos(j0);
IkReal x1112=((1.0)*py);
IkReal x1113=((1.0)*x1111);
evalcond[0]=(((x1111*(((((-1.0)*px*x1109*x1112))+(((-1.0)*px*x1108*x1112))))))+((x1110*((((x1107*x1109))+((x1107*x1108)))))));
evalcond[1]=(((px*x1110))+(((-1.0)*x1111*x1112)));
evalcond[2]=((((-1.0)*px*x1113))+(((-1.0)*x1110*x1112)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x1114=((1.0)*sj2);
j1eval[0]=((((-1.0)*cj0*px*x1114))+(((-1.0)*py*sj0*x1114)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x1115=((1.0)*cj2);
j1eval[0]=((((-1.0)*cj0*px*x1115))+(((-1.0)*py*sj0*x1115)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j1eval[0]=IKabs((((cj0*px))+((py*sj0))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(px)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1116=(cj0*px);
IkReal x1117=(py*sj0);
op[0]=(x1117+x1116);
op[1]=0;
op[2]=((((-1.0)*x1117))+(((-1.0)*x1116)));
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
j1eval[0]=IKabs(((((-1.0)*py*sj0))+(((-1.0)*cj0*px))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(px)));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1118=(cj0*px);
IkReal x1119=(py*sj0);
op[0]=((((-1.0)*x1119))+(((-1.0)*x1118)));
op[1]=0;
op[2]=(x1119+x1118);
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj2=0;
cj2=1.0;
j2=0;
j1eval[0]=IKabs((((cj0*px))+((py*sj0))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(px)));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1120=(cj0*px);
IkReal x1121=(py*sj0);
op[0]=(x1120+x1121);
op[1]=0;
op[2]=((((-1.0)*x1120))+(((-1.0)*x1121)));
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j1eval[0]=IKabs(((((-1.0)*py*sj0))+(((-1.0)*cj0*px))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(px)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1122=(cj0*px);
IkReal x1123=(py*sj0);
op[0]=((((-1.0)*x1122))+(((-1.0)*x1123)));
op[1]=0;
op[2]=(x1122+x1123);
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(px)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x1124=((1.0)*px);
CheckValue<IkReal> x1127=IKPowWithIntegerCheck(((((-1.0)*cj0*cj2*x1124))+(((-1.0)*cj2*py*sj0))),-1);
if(!x1127.valid){
continue;
}
IkReal x1125=x1127.value;
IkReal x1126=(sj2*x1125);
CheckValue<IkReal> x1128=IKPowWithIntegerCheck(((((-1.0)*cj0*cj2*px))+(((-1.0)*cj2*py*sj0))),-1);
if(!x1128.valid){
continue;
}
cj1array[0]=((((-1.0)*sj0*sj2*x1124*(x1128.value)))+((cj0*py*x1126)));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[3];
IkReal x1129=IKsin(j1);
IkReal x1130=IKcos(j1);
IkReal x1131=((1.0)*px);
IkReal x1132=(sj2*x1130);
IkReal x1133=(cj0*px*x1129);
IkReal x1134=(py*sj0*x1129);
evalcond[0]=((((0.8)*x1134))+(((0.8)*x1133)));
evalcond[1]=((((-1.0)*x1134))+(((-1.0)*cj0*x1129*x1131)));
evalcond[2]=((((-1.0)*cj0*x1131*x1132))+(((-1.0)*cj2*sj0*x1131))+(((-1.0)*py*sj0*x1132))+((cj0*cj2*py)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x1135=((1.0)*cj0);
CheckValue<IkReal> x1138=IKPowWithIntegerCheck(((((-1.0)*px*sj2*x1135))+(((-1.0)*py*sj0*sj2))),-1);
if(!x1138.valid){
continue;
}
IkReal x1136=x1138.value;
IkReal x1137=(cj2*x1136);
CheckValue<IkReal> x1139=IKPowWithIntegerCheck(((((-1.0)*cj0*px*sj2))+(((-1.0)*py*sj0*sj2))),-1);
if(!x1139.valid){
continue;
}
cj1array[0]=((((-1.0)*cj2*py*x1135*(x1139.value)))+((px*sj0*x1137)));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[3];
IkReal x1140=IKsin(j1);
IkReal x1141=IKcos(j1);
IkReal x1142=((1.0)*py);
IkReal x1143=(sj0*x1140);
IkReal x1144=(cj2*x1141);
IkReal x1145=(cj0*px*x1140);
evalcond[0]=((((0.8)*x1145))+(((0.8)*py*x1143)));
evalcond[1]=((((-1.0)*x1145))+(((-1.0)*x1142*x1143)));
evalcond[2]=((((-1.0)*cj0*px*x1144))+((px*sj0*sj2))+(((-1.0)*sj0*x1142*x1144))+(((-1.0)*cj0*sj2*x1142)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1147 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1147.valid){
continue;
}
IkReal x1146=x1147.value;
j0array[0]=((-1.0)*x1146);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1146)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x1148=((1.0)*sj2);
j1eval[0]=((((-1.0)*py*sj0*x1148))+(((-1.0)*cj0*px*x1148)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x1149=((1.0)*cj2);
j1eval[0]=((((-1.0)*py*sj0*x1149))+(((-1.0)*cj0*px*x1149)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j1eval[0]=IKabs((((cj0*px))+((py*sj0))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(px)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1150=(cj0*px);
IkReal x1151=(py*sj0);
op[0]=(x1151+x1150);
op[1]=0;
op[2]=((((-1.0)*x1151))+(((-1.0)*x1150)));
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
j1eval[0]=IKabs(((((-1.0)*py*sj0))+(((-1.0)*cj0*px))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(px)));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1152=(cj0*px);
IkReal x1153=(py*sj0);
op[0]=((((-1.0)*x1152))+(((-1.0)*x1153)));
op[1]=0;
op[2]=(x1153+x1152);
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj2=0;
cj2=1.0;
j2=0;
j1eval[0]=IKabs((((cj0*px))+((py*sj0))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(px)));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1154=(cj0*px);
IkReal x1155=(py*sj0);
op[0]=(x1155+x1154);
op[1]=0;
op[2]=((((-1.0)*x1155))+(((-1.0)*x1154)));
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j1eval[0]=IKabs(((((-1.0)*py*sj0))+(((-1.0)*cj0*px))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(px)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1156=(cj0*px);
IkReal x1157=(py*sj0);
op[0]=((((-1.0)*x1157))+(((-1.0)*x1156)));
op[1]=0;
op[2]=(x1157+x1156);
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(px)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
evalcond[1]=py;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x1158=((1.0)*px);
CheckValue<IkReal> x1161=IKPowWithIntegerCheck(((((-1.0)*cj2*py*sj0))+(((-1.0)*cj0*cj2*x1158))),-1);
if(!x1161.valid){
continue;
}
IkReal x1159=x1161.value;
IkReal x1160=(sj2*x1159);
CheckValue<IkReal> x1162=IKPowWithIntegerCheck(((((-1.0)*cj0*cj2*px))+(((-1.0)*cj2*py*sj0))),-1);
if(!x1162.valid){
continue;
}
cj1array[0]=((((-1.0)*sj0*sj2*x1158*(x1162.value)))+((cj0*py*x1160)));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[3];
IkReal x1163=IKsin(j1);
IkReal x1164=IKcos(j1);
IkReal x1165=((1.0)*px);
IkReal x1166=(sj2*x1164);
IkReal x1167=(cj0*px*x1163);
IkReal x1168=(py*sj0*x1163);
evalcond[0]=((((0.8)*x1167))+(((0.8)*x1168)));
evalcond[1]=((((-1.0)*cj0*x1163*x1165))+(((-1.0)*x1168)));
evalcond[2]=((((-1.0)*cj2*sj0*x1165))+(((-1.0)*cj0*x1165*x1166))+((cj0*cj2*py))+(((-1.0)*py*sj0*x1166)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x1169=((1.0)*cj0);
CheckValue<IkReal> x1172=IKPowWithIntegerCheck(((((-1.0)*px*sj2*x1169))+(((-1.0)*py*sj0*sj2))),-1);
if(!x1172.valid){
continue;
}
IkReal x1170=x1172.value;
IkReal x1171=(cj2*x1170);
CheckValue<IkReal> x1173=IKPowWithIntegerCheck(((((-1.0)*cj0*px*sj2))+(((-1.0)*py*sj0*sj2))),-1);
if(!x1173.valid){
continue;
}
cj1array[0]=((((-1.0)*cj2*py*x1169*(x1173.value)))+((px*sj0*x1171)));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[3];
IkReal x1174=IKsin(j1);
IkReal x1175=IKcos(j1);
IkReal x1176=((1.0)*py);
IkReal x1177=(sj0*x1174);
IkReal x1178=(cj2*x1175);
IkReal x1179=(cj0*px*x1174);
evalcond[0]=((((0.8)*py*x1177))+(((0.8)*x1179)));
evalcond[1]=((((-1.0)*x1176*x1177))+(((-1.0)*x1179)));
evalcond[2]=((((-1.0)*sj0*x1176*x1178))+((px*sj0*sj2))+(((-1.0)*cj0*sj2*x1176))+(((-1.0)*cj0*px*x1178)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x1180=py*py;
IkReal x1181=sj2*sj2;
IkReal x1182=cj2*cj2;
IkReal x1183=(px*py);
IkReal x1184=((1.0)*x1180);
IkReal x1185=(((x1182*x1183))+((x1181*x1183)));
IkReal x1186=((((-1.0)*x1181*x1184))+(((-1.0)*x1182*x1184)));
CheckValue<IkReal> x1189 = IKatan2WithCheck(IkReal(x1186),IkReal(x1185),IKFAST_ATAN2_MAGTHRESH);
if(!x1189.valid){
continue;
}
IkReal x1187=((1.0)*(x1189.value));
if((((x1186*x1186)+(x1185*x1185))) < -0.00001)
continue;
CheckValue<IkReal> x1190=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1186*x1186)+(x1185*x1185)))),-1);
if(!x1190.valid){
continue;
}
if( (((0.4)*py*sj2*sj3*(x1190.value))) < -1-IKFAST_SINCOS_THRESH || (((0.4)*py*sj2*sj3*(x1190.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1188=IKasin(((0.4)*py*sj2*sj3*(x1190.value)));
j0array[0]=(x1188+(((-1.0)*x1187)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1187))+(((-1.0)*x1188)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x1191=px*px;
IkReal x1192=IKsin(j0);
IkReal x1193=IKcos(j0);
IkReal x1194=cj2*cj2;
IkReal x1195=sj2*sj2;
IkReal x1196=((1.0)*py);
IkReal x1197=((0.4)*sj2*sj3);
evalcond[0]=((((-1.0)*x1193*x1196))+(((-1.0)*x1197))+((px*x1192)));
evalcond[1]=(((x1192*((((x1191*x1194))+((x1191*x1195))))))+(((-1.0)*px*x1197))+((x1193*(((((-1.0)*px*x1194*x1196))+(((-1.0)*px*x1195*x1196)))))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[3];
IkReal x1198=(py*sj0);
IkReal x1199=((8.0)*cj3);
IkReal x1200=((20.0)*pz);
IkReal x1201=(cj0*px);
IkReal x1202=((10.0)*pp);
IkReal x1203=((1.0)*cj3);
IkReal x1204=(cj2*sj3);
j1eval[0]=((((-1.0)*x1201))+((pz*x1204))+(((-1.0)*x1201*x1203))+(((-1.0)*x1198))+(((-1.0)*x1198*x1203)));
j1eval[1]=((IKabs(((((-1.0)*cj3*x1202))+((pz*x1200))+(((-1.0)*x1202)))))+(IKabs((((x1202*x1204))+(((-1.0)*x1200*x1201))+(((-1.0)*x1198*x1200))))));
j1eval[2]=IKsign(((((-1.0)*x1199*x1201))+(((-1.0)*x1198*x1199))+(((8.0)*pz*x1204))+(((-8.0)*x1201))+(((-8.0)*x1198))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
IkReal x1205=((2.0)*cj3);
IkReal x1206=(py*sj0);
IkReal x1207=(cj0*px);
IkReal x1208=(cj2*sj3);
IkReal x1209=((5.0)*pz);
IkReal x1210=((1.0)*cj3);
j1eval[0]=((((-1.0)*x1207*x1210))+(((-1.0)*x1206*x1210))+(((-1.0)*x1207))+(((-1.0)*x1206))+((pz*x1208)));
j1eval[1]=((IKabs(((-0.8)+(((-1.6)*cj3))+((pz*x1209))+(((-0.8)*(cj3*cj3))))))+(IKabs(((((0.8)*cj3*x1208))+(((0.8)*x1208))+(((-1.0)*x1206*x1209))+(((-1.0)*x1207*x1209))))));
j1eval[2]=IKsign(((((2.0)*pz*x1208))+(((-2.0)*x1207))+(((-2.0)*x1206))+(((-1.0)*x1205*x1207))+(((-1.0)*x1205*x1206))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
IkReal x1211=cj2*cj2;
IkReal x1212=cj3*cj3;
IkReal x1213=((10.0)*cj3);
IkReal x1214=(py*sj0);
IkReal x1215=(cj0*px);
IkReal x1216=((10.0)*cj2*sj3);
IkReal x1217=(x1211*x1212);
j1eval[0]=((1.0)+x1212+x1211+(((2.0)*cj3))+(((-1.0)*x1217)));
j1eval[1]=IKsign(((4.0)+(((8.0)*cj3))+(((-4.0)*x1217))+(((4.0)*x1211))+(((4.0)*x1212))));
j1eval[2]=((IKabs(((((-1.0)*x1215*x1216))+(((-1.0)*x1214*x1216))+(((10.0)*pz))+((pz*x1213)))))+(IKabs((((x1213*x1215))+((x1213*x1214))+(((10.0)*x1215))+(((10.0)*x1214))+((pz*x1216))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1218=cj2*cj2;
IkReal x1219=cj3*cj3;
IkReal x1220=((10.0)*cj3);
IkReal x1221=(py*sj0);
IkReal x1222=(cj0*px);
IkReal x1223=((4.0)*x1219);
IkReal x1224=((10.0)*cj2*sj3);
CheckValue<IkReal> x1225=IKPowWithIntegerCheck(IKsign(((4.0)+x1223+(((8.0)*cj3))+(((-1.0)*x1218*x1223))+(((4.0)*x1218)))),-1);
if(!x1225.valid){
continue;
}
CheckValue<IkReal> x1226 = IKatan2WithCheck(IkReal((((pz*x1224))+(((10.0)*x1221))+(((10.0)*x1222))+((x1220*x1221))+((x1220*x1222)))),IkReal((((pz*x1220))+(((-1.0)*x1221*x1224))+(((-1.0)*x1222*x1224))+(((10.0)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1226.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1225.value)))+(x1226.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1227=IKcos(j1);
IkReal x1228=IKsin(j1);
IkReal x1229=(px*sj0);
IkReal x1230=((0.4)*cj3);
IkReal x1231=((1.0)*cj2);
IkReal x1232=((0.4)*sj3);
IkReal x1233=(py*sj0);
IkReal x1234=(cj0*py);
IkReal x1235=((1.0)*cj0*px);
IkReal x1236=((1.0)*x1227);
IkReal x1237=(cj2*x1228);
IkReal x1238=((0.8)*x1228);
IkReal x1239=(cj2*x1227);
evalcond[0]=((((-1.0)*x1227*x1230))+pz+(((-0.4)*x1227))+(((-1.0)*x1232*x1237)));
evalcond[1]=((((0.8)*pz*x1227))+(((-1.0)*pp))+((x1233*x1238))+((cj0*px*x1238)));
evalcond[2]=((0.4)+x1230+(((-1.0)*pz*x1236))+(((-1.0)*x1228*x1235))+(((-1.0)*x1228*x1233)));
evalcond[3]=((((-1.0)*x1233))+(((-1.0)*x1235))+(((0.4)*x1228))+((x1228*x1230))+(((-1.0)*x1232*x1239)));
evalcond[4]=((((-1.0)*sj2*x1227*x1235))+((cj2*x1234))+((pz*sj2*x1228))+(((-1.0)*sj2*x1233*x1236))+(((-1.0)*x1229*x1231)));
evalcond[5]=(((sj2*x1229))+((pz*x1237))+(((-1.0)*x1227*x1231*x1233))+(((-1.0)*x1232))+(((-1.0)*cj0*px*x1227*x1231))+(((-1.0)*sj2*x1234)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1240=((2.0)*cj3);
IkReal x1241=(py*sj0);
IkReal x1242=(cj0*px);
IkReal x1243=(cj2*sj3);
IkReal x1244=((5.0)*pz);
CheckValue<IkReal> x1245 = IKatan2WithCheck(IkReal(((-0.8)+((pz*x1244))+(((-1.6)*cj3))+(((-0.8)*(cj3*cj3))))),IkReal(((((0.8)*cj3*x1243))+(((-1.0)*x1242*x1244))+(((-1.0)*x1241*x1244))+(((0.8)*x1243)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1245.valid){
continue;
}
CheckValue<IkReal> x1246=IKPowWithIntegerCheck(IKsign(((((2.0)*pz*x1243))+(((-1.0)*x1240*x1242))+(((-1.0)*x1240*x1241))+(((-2.0)*x1242))+(((-2.0)*x1241)))),-1);
if(!x1246.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1245.value)+(((1.5707963267949)*(x1246.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1247=IKcos(j1);
IkReal x1248=IKsin(j1);
IkReal x1249=(px*sj0);
IkReal x1250=((0.4)*cj3);
IkReal x1251=((1.0)*cj2);
IkReal x1252=((0.4)*sj3);
IkReal x1253=(py*sj0);
IkReal x1254=(cj0*py);
IkReal x1255=((1.0)*cj0*px);
IkReal x1256=((1.0)*x1247);
IkReal x1257=(cj2*x1248);
IkReal x1258=((0.8)*x1248);
IkReal x1259=(cj2*x1247);
evalcond[0]=((((-1.0)*x1252*x1257))+(((-1.0)*x1247*x1250))+pz+(((-0.4)*x1247)));
evalcond[1]=((((0.8)*pz*x1247))+((cj0*px*x1258))+((x1253*x1258))+(((-1.0)*pp)));
evalcond[2]=((0.4)+x1250+(((-1.0)*x1248*x1255))+(((-1.0)*x1248*x1253))+(((-1.0)*pz*x1256)));
evalcond[3]=((((-1.0)*x1255))+(((0.4)*x1248))+(((-1.0)*x1252*x1259))+(((-1.0)*x1253))+((x1248*x1250)));
evalcond[4]=((((-1.0)*x1249*x1251))+((pz*sj2*x1248))+((cj2*x1254))+(((-1.0)*sj2*x1253*x1256))+(((-1.0)*sj2*x1247*x1255)));
evalcond[5]=((((-1.0)*x1252))+((sj2*x1249))+(((-1.0)*x1247*x1251*x1253))+(((-1.0)*sj2*x1254))+(((-1.0)*cj0*px*x1247*x1251))+((pz*x1257)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1260=(py*sj0);
IkReal x1261=((8.0)*cj3);
IkReal x1262=((20.0)*pz);
IkReal x1263=(cj0*px);
IkReal x1264=((10.0)*pp);
IkReal x1265=(cj2*sj3);
CheckValue<IkReal> x1266 = IKatan2WithCheck(IkReal(((((-1.0)*cj3*x1264))+((pz*x1262))+(((-1.0)*x1264)))),IkReal(((((-1.0)*x1260*x1262))+((x1264*x1265))+(((-1.0)*x1262*x1263)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1266.valid){
continue;
}
CheckValue<IkReal> x1267=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1261*x1263))+(((-1.0)*x1260*x1261))+(((-8.0)*x1260))+(((-8.0)*x1263))+(((8.0)*pz*x1265)))),-1);
if(!x1267.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1266.value)+(((1.5707963267949)*(x1267.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1268=IKcos(j1);
IkReal x1269=IKsin(j1);
IkReal x1270=(px*sj0);
IkReal x1271=((0.4)*cj3);
IkReal x1272=((1.0)*cj2);
IkReal x1273=((0.4)*sj3);
IkReal x1274=(py*sj0);
IkReal x1275=(cj0*py);
IkReal x1276=((1.0)*cj0*px);
IkReal x1277=((1.0)*x1268);
IkReal x1278=(cj2*x1269);
IkReal x1279=((0.8)*x1269);
IkReal x1280=(cj2*x1268);
evalcond[0]=((((-0.4)*x1268))+(((-1.0)*x1268*x1271))+(((-1.0)*x1273*x1278))+pz);
evalcond[1]=(((cj0*px*x1279))+((x1274*x1279))+(((-1.0)*pp))+(((0.8)*pz*x1268)));
evalcond[2]=((0.4)+x1271+(((-1.0)*x1269*x1274))+(((-1.0)*x1269*x1276))+(((-1.0)*pz*x1277)));
evalcond[3]=(((x1269*x1271))+(((-1.0)*x1276))+(((-1.0)*x1273*x1280))+(((-1.0)*x1274))+(((0.4)*x1269)));
evalcond[4]=((((-1.0)*x1270*x1272))+(((-1.0)*sj2*x1268*x1276))+(((-1.0)*sj2*x1274*x1277))+((cj2*x1275))+((pz*sj2*x1269)));
evalcond[5]=(((pz*x1278))+((sj2*x1270))+(((-1.0)*x1273))+(((-1.0)*x1268*x1272*x1274))+(((-1.0)*cj0*px*x1268*x1272))+(((-1.0)*sj2*x1275)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x1281=((-0.4)+(((-0.4)*cj3)));
CheckValue<IkReal> x1284 = IKatan2WithCheck(IkReal(x1281),IkReal(((-0.4)*cj2*sj3)),IKFAST_ATAN2_MAGTHRESH);
if(!x1284.valid){
continue;
}
IkReal x1282=((1.0)*(x1284.value));
if((((x1281*x1281)+(((0.16)*(cj2*cj2)*(sj3*sj3))))) < -0.00001)
continue;
CheckValue<IkReal> x1285=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1281*x1281)+(((0.16)*(cj2*cj2)*(sj3*sj3)))))),-1);
if(!x1285.valid){
continue;
}
if( ((pz*(x1285.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x1285.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1283=IKasin((pz*(x1285.value)));
j1array[0]=((((-1.0)*x1283))+(((-1.0)*x1282)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+x1283+(((-1.0)*x1282)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j0eval[3];
IkReal x1286=pz*pz;
IkReal x1287=((20.0)*sj1);
IkReal x1288=((25.0)*pp);
IkReal x1289=((20.0)*cj1*pz);
IkReal x1290=((8.0)*sj1*sj2*sj3);
j0eval[0]=(((pp*sj1))+(((-1.0)*sj1*x1286)));
j0eval[1]=((IKabs((((py*x1288))+(((-1.0)*py*x1289))+((px*x1290)))))+(IKabs(((((-1.0)*px*x1289))+((px*x1288))+(((-1.0)*py*x1290))))));
j0eval[2]=IKsign((((pp*x1287))+(((-1.0)*x1286*x1287))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
IkReal x1291=pz*pz;
IkReal x1292=((2.0)*px);
IkReal x1293=(pp*sj1);
IkReal x1294=((2.0)*py);
IkReal x1295=(sj1*x1291);
IkReal x1296=((5.0)*cj1*pz);
IkReal x1297=(sj1*sj2*sj3);
j0eval[0]=(x1293+(((-1.0)*x1295)));
j0eval[1]=((IKabs((x1294+((cj3*x1294))+(((-1.0)*py*x1296))+((x1292*x1297)))))+(IKabs((x1292+((cj3*x1292))+(((-1.0)*px*x1296))+(((-1.0)*x1294*x1297))))));
j0eval[2]=IKsign(((((-5.0)*x1295))+(((5.0)*x1293))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
IkReal x1298=pz*pz;
IkReal x1299=((2.0)*sj3);
IkReal x1300=(cj1*cj2);
IkReal x1301=((2.0)*sj1);
j0eval[0]=(pp+(((-1.0)*x1298)));
j0eval[1]=IKsign(((((-5.0)*x1298))+(((5.0)*pp))));
j0eval[2]=((IKabs((((cj3*px*x1301))+((px*x1301))+(((-1.0)*py*sj2*x1299))+(((-1.0)*px*x1299*x1300)))))+(IKabs((((py*x1301))+((px*sj2*x1299))+((cj3*py*x1301))+(((-1.0)*py*x1299*x1300))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=0.64;
j0eval[1]=sj1;
j0eval[2]=(pp+(((-1.0)*(pz*pz))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs((py*sj1)))+(IKabs((px*sj1))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj1=0;
cj1=1.0;
j1=0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj1=0;
cj1=1.0;
j1=0;
IkReal x1302=((1.0)*px);
j0eval[0]=((IKabs((((cj2*py))+(((-1.0)*sj2*x1302)))))+(IKabs(((((-1.0)*cj2*x1302))+(((-1.0)*py*sj2))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj1=0;
cj1=1.0;
j1=0;
IkReal x1303=((1.0)*py);
j0eval[0]=((IKabs(((((-1.0)*cj2*px))+(((-1.0)*sj2*x1303)))))+(IKabs(((((-1.0)*cj2*x1303))+((px*sj2))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x1304=((1.0)*cj2);
CheckValue<IkReal> x1306 = IKatan2WithCheck(IkReal(((((-1.0)*px*x1304))+(((-1.0)*py*sj2)))),IkReal((((px*sj2))+(((-1.0)*py*x1304)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1306.valid){
continue;
}
IkReal x1305=x1306.value;
j0array[0]=((-1.0)*x1305);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1305)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x1307=IKcos(j0);
IkReal x1308=IKsin(j0);
IkReal x1309=(px*x1308);
IkReal x1310=((1.0)*x1307);
IkReal x1311=((1.0)*py*x1308);
evalcond[0]=(x1309+(((-1.0)*py*x1310)));
evalcond[1]=((((-1.0)*x1311))+(((-1.0)*px*x1310)));
evalcond[2]=((((-1.0)*cj2*x1309))+((cj2*py*x1307))+(((-1.0)*sj2*x1311))+(((-1.0)*px*sj2*x1310)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x1312=((1.0)*px);
CheckValue<IkReal> x1314 = IKatan2WithCheck(IkReal(((((-1.0)*sj2*x1312))+((cj2*py)))),IkReal(((((-1.0)*cj2*x1312))+(((-1.0)*py*sj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1314.valid){
continue;
}
IkReal x1313=x1314.value;
j0array[0]=((-1.0)*x1313);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1313)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x1315=IKcos(j0);
IkReal x1316=IKsin(j0);
IkReal x1317=(px*x1316);
IkReal x1318=((1.0)*x1315);
IkReal x1319=((1.0)*py*x1316);
evalcond[0]=(x1317+(((-1.0)*py*x1318)));
evalcond[1]=((((-1.0)*x1319))+(((-1.0)*px*x1318)));
evalcond[2]=((((-1.0)*cj2*x1319))+((sj2*x1317))+(((-1.0)*py*sj2*x1318))+(((-1.0)*cj2*px*x1318)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1321 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1321.valid){
continue;
}
IkReal x1320=x1321.value;
j0array[0]=((-1.0)*x1320);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1320)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x1322=IKcos(j0);
IkReal x1323=IKsin(j0);
IkReal x1324=((1.0)*px);
IkReal x1325=(cj2*x1323);
IkReal x1326=(py*x1322);
IkReal x1327=((1.0)*py*x1323);
evalcond[0]=((((-1.0)*x1322*x1324))+(((-1.0)*x1327)));
evalcond[1]=((((-1.0)*sj2*x1322*x1324))+(((-1.0)*x1324*x1325))+((cj2*x1326))+(((-1.0)*sj2*x1327)));
evalcond[2]=((((-1.0)*sj2*x1326))+(((-1.0)*cj2*x1322*x1324))+(((-1.0)*py*x1325))+((px*sj2*x1323)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
j0eval[0]=((IKabs(((((-1.0)*cj2*px))+((py*sj2)))))+(IKabs((((cj2*py))+((px*sj2))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
j0eval[0]=((IKabs((((cj2*px))+(((-1.0)*py*sj2)))))+(IKabs((((cj2*py))+((px*sj2))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1329 = IKatan2WithCheck(IkReal((((cj2*px))+(((-1.0)*py*sj2)))),IkReal((((cj2*py))+((px*sj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1329.valid){
continue;
}
IkReal x1328=x1329.value;
j0array[0]=((-1.0)*x1328);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1328)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x1330=IKcos(j0);
IkReal x1331=IKsin(j0);
IkReal x1332=(px*x1331);
IkReal x1333=((1.0)*x1330);
IkReal x1334=(py*x1331);
evalcond[0]=(x1332+(((-1.0)*py*x1333)));
evalcond[1]=((((-1.0)*px*x1333))+(((-1.0)*x1334)));
evalcond[2]=((((-1.0)*cj2*x1332))+((cj2*py*x1330))+((px*sj2*x1330))+((sj2*x1334)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1336 = IKatan2WithCheck(IkReal((((cj2*py))+((px*sj2)))),IkReal(((((-1.0)*cj2*px))+((py*sj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1336.valid){
continue;
}
IkReal x1335=x1336.value;
j0array[0]=((-1.0)*x1335);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1335)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x1337=IKcos(j0);
IkReal x1338=IKsin(j0);
IkReal x1339=(px*x1338);
IkReal x1340=((1.0)*x1337);
IkReal x1341=(py*x1338);
evalcond[0]=(x1339+(((-1.0)*py*x1340)));
evalcond[1]=((((-1.0)*px*x1340))+(((-1.0)*x1341)));
evalcond[2]=((((-1.0)*py*sj2*x1340))+((cj2*px*x1337))+((sj2*x1339))+((cj2*x1341)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1343 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1343.valid){
continue;
}
IkReal x1342=x1343.value;
j0array[0]=((-1.0)*x1342);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1342)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x1344=IKcos(j0);
IkReal x1345=IKsin(j0);
IkReal x1346=((1.0)*px);
IkReal x1347=(px*sj2);
IkReal x1348=(cj2*x1345);
IkReal x1349=(py*x1344);
IkReal x1350=(py*x1345);
evalcond[0]=((((-1.0)*x1350))+(((-1.0)*x1344*x1346)));
evalcond[1]=((((-1.0)*x1346*x1348))+((x1344*x1347))+((sj2*x1350))+((cj2*x1349)));
evalcond[2]=(((x1345*x1347))+(((-1.0)*sj2*x1349))+((cj2*px*x1344))+((py*x1348)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x1351=((-1.0)*sj1);
CheckValue<IkReal> x1353 = IKatan2WithCheck(IkReal((px*x1351)),IkReal((py*x1351)),IKFAST_ATAN2_MAGTHRESH);
if(!x1353.valid){
continue;
}
IkReal x1352=x1353.value;
j0array[0]=((-1.0)*x1352);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1352)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1354=IKcos(j0);
IkReal x1355=IKsin(j0);
IkReal x1356=(cj1*cj2);
IkReal x1357=((0.8)*sj1);
IkReal x1358=(cj1*sj2);
IkReal x1359=(px*x1355);
IkReal x1360=(py*x1354);
IkReal x1361=((1.0)*px*x1354);
IkReal x1362=((1.0)*py*x1355);
evalcond[0]=(x1359+(((-1.0)*x1360)));
evalcond[1]=((((-1.0)*x1361))+(((-1.0)*x1362)));
evalcond[2]=(((py*x1355*x1357))+((px*x1354*x1357)));
evalcond[3]=((((-1.0)*cj2*x1359))+((cj2*x1360))+(((-1.0)*x1358*x1362))+(((-1.0)*x1358*x1361)));
evalcond[4]=((((-1.0)*sj2*x1360))+(((-1.0)*x1356*x1361))+(((-1.0)*x1356*x1362))+((sj2*x1359)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x1363=((0.8)*sj1);
CheckValue<IkReal> x1365 = IKatan2WithCheck(IkReal((px*x1363)),IkReal((py*x1363)),IKFAST_ATAN2_MAGTHRESH);
if(!x1365.valid){
continue;
}
IkReal x1364=x1365.value;
j0array[0]=((-1.0)*x1364);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1364)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1366=IKcos(j0);
IkReal x1367=IKsin(j0);
IkReal x1368=(cj1*cj2);
IkReal x1369=(cj1*sj2);
IkReal x1370=(px*x1367);
IkReal x1371=(py*x1366);
IkReal x1372=((1.0)*px*x1366);
IkReal x1373=((1.0)*py*x1367);
evalcond[0]=(x1370+(((-1.0)*x1371)));
evalcond[1]=((((-1.0)*x1372))+(((-1.0)*x1373)));
evalcond[2]=((((-1.0)*sj1*x1373))+(((-1.0)*sj1*x1372)));
evalcond[3]=(((cj2*x1371))+(((-1.0)*x1369*x1372))+(((-1.0)*x1369*x1373))+(((-1.0)*cj2*x1370)));
evalcond[4]=((((-1.0)*sj2*x1371))+((sj2*x1370))+(((-1.0)*x1368*x1373))+(((-1.0)*x1368*x1372)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1375 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1375.valid){
continue;
}
IkReal x1374=x1375.value;
j0array[0]=((-1.0)*x1374);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1374)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1376=IKcos(j0);
IkReal x1377=IKsin(j0);
IkReal x1378=((1.0)*px);
IkReal x1379=((1.0)*py);
IkReal x1380=(cj2*x1377);
IkReal x1381=(cj2*x1376);
IkReal x1382=(sj1*x1376);
IkReal x1383=(sj2*x1377);
IkReal x1384=(sj2*x1376);
IkReal x1385=(sj1*x1377);
evalcond[0]=((((-1.0)*x1377*x1379))+(((-1.0)*x1376*x1378)));
evalcond[1]=((((0.8)*py*x1385))+(((0.8)*px*x1382)));
evalcond[2]=((((-1.0)*x1378*x1382))+(((-1.0)*x1379*x1385)));
evalcond[3]=((((-1.0)*cj1*x1378*x1384))+((py*x1381))+(((-1.0)*x1378*x1380))+(((-1.0)*cj1*x1379*x1383)));
evalcond[4]=((((-1.0)*cj1*x1378*x1381))+(((-1.0)*x1379*x1384))+(((-1.0)*cj1*x1379*x1380))+((px*x1383)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=0;
cj1=1.0;
j1=0;
IkReal x1386=pz*pz;
IkReal x1387=(px*sj3);
IkReal x1388=((1.0)*py*sj3);
j0eval[0]=(pp+(((-1.0)*x1386)));
j0eval[1]=IKsign(((((-5.0)*x1386))+(((5.0)*pp))));
j0eval[2]=((IKabs(((((-1.0)*cj2*x1387))+(((-1.0)*sj2*x1388)))))+(IKabs((((sj2*x1387))+(((-1.0)*cj2*x1388))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=0;
cj1=1.0;
j1=0;
IkReal x1389=pz*pz;
IkReal x1390=cj2*cj2;
IkReal x1391=((1.0)*cj2);
IkReal x1392=(px*sj3);
IkReal x1393=((5.0)*cj2);
IkReal x1394=(py*sj3);
j0eval[0]=(((cj2*x1389))+(((-1.0)*pp*x1391)));
j0eval[1]=IKsign((((x1389*x1393))+(((-1.0)*pp*x1393))));
j0eval[2]=((IKabs((((x1390*x1394))+(((-1.0)*sj2*x1391*x1392)))))+(IKabs((((cj2*sj2*x1394))+((x1390*x1392))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=0;
cj1=1.0;
j1=0;
IkReal x1395=pz*pz;
IkReal x1396=cj2*cj2;
IkReal x1397=((5.0)*sj2);
IkReal x1398=(py*sj3);
IkReal x1399=(cj2*sj2);
IkReal x1400=(px*sj3);
j0eval[0]=((((-1.0)*pp*sj2))+((sj2*x1395)));
j0eval[1]=IKsign((((x1395*x1397))+(((-1.0)*pp*x1397))));
j0eval[2]=((IKabs((x1398+((x1399*x1400))+(((-1.0)*x1396*x1398)))))+(IKabs(((((-1.0)*x1400))+((x1398*x1399))+((x1396*x1400))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[4];
sj1=0;
cj1=1.0;
j1=0;
sj2=0;
cj2=1.0;
j2=0;
IkReal x1401=pz*pz;
j0eval[0]=((((-1.0)*pp))+x1401);
j0eval[1]=4.0;
j0eval[2]=sj3;
j0eval[3]=IKsign(((((5.0)*x1401))+(((-5.0)*pp))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj2=0;
cj2=1.0;
j2=0;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1403 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1403.valid){
continue;
}
IkReal x1402=x1403.value;
j0array[0]=((-1.0)*x1402);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1402)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj2=0;
cj2=1.0;
j2=0;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1405 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1405.valid){
continue;
}
IkReal x1404=x1405.value;
j0array[0]=((-1.0)*x1404);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1404)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1406=((2.0)*sj3);
CheckValue<IkReal> x1407 = IKatan2WithCheck(IkReal((py*x1406)),IkReal((px*x1406)),IKFAST_ATAN2_MAGTHRESH);
if(!x1407.valid){
continue;
}
CheckValue<IkReal> x1408=IKPowWithIntegerCheck(IKsign(((((5.0)*(pz*pz)))+(((-5.0)*pp)))),-1);
if(!x1408.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1407.value)+(((1.5707963267949)*(x1408.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x1409=IKcos(j0);
IkReal x1410=IKsin(j0);
IkReal x1411=((1.0)*py);
evalcond[0]=(((px*x1410))+(((-1.0)*x1409*x1411)));
evalcond[1]=((((-1.0)*x1410*x1411))+(((-1.0)*px*x1409))+(((-0.4)*sj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[4];
sj1=0;
cj1=1.0;
j1=0;
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
IkReal x1412=pz*pz;
j0eval[0]=(pp+(((-1.0)*x1412)));
j0eval[1]=IKsign(((((-5.0)*x1412))+(((5.0)*pp))));
j0eval[2]=4.0;
j0eval[3]=sj3;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1414 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1414.valid){
continue;
}
IkReal x1413=x1414.value;
j0array[0]=((-1.0)*x1413);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1413)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1416 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1416.valid){
continue;
}
IkReal x1415=x1416.value;
j0array[0]=((-1.0)*x1415);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1415)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1417=((2.0)*sj3);
CheckValue<IkReal> x1418 = IKatan2WithCheck(IkReal((py*x1417)),IkReal((px*x1417)),IKFAST_ATAN2_MAGTHRESH);
if(!x1418.valid){
continue;
}
CheckValue<IkReal> x1419=IKPowWithIntegerCheck(IKsign(((((-5.0)*(pz*pz)))+(((5.0)*pp)))),-1);
if(!x1419.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1418.value)+(((1.5707963267949)*(x1419.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x1420=IKcos(j0);
IkReal x1421=IKsin(j0);
IkReal x1422=((1.0)*py);
evalcond[0]=((((-1.0)*x1420*x1422))+((px*x1421)));
evalcond[1]=((((-1.0)*x1421*x1422))+(((-1.0)*px*x1420))+(((0.4)*sj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj3=0;
cj3=1.0;
j3=0;
IkReal x1423=((1.0)*px);
j0eval[0]=((IKabs(((((-1.0)*cj2*x1423))+(((-1.0)*py*sj2)))))+(IKabs(((((-1.0)*sj2*x1423))+((cj2*py))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj3=0;
cj3=1.0;
j3=0;
IkReal x1424=((1.0)*py);
j0eval[0]=((IKabs(((((-1.0)*cj2*x1424))+((px*sj2)))))+(IKabs(((((-1.0)*cj2*px))+(((-1.0)*sj2*x1424))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x1425=((1.0)*cj2);
CheckValue<IkReal> x1427 = IKatan2WithCheck(IkReal(((((-1.0)*px*x1425))+(((-1.0)*py*sj2)))),IkReal(((((-1.0)*py*x1425))+((px*sj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1427.valid){
continue;
}
IkReal x1426=x1427.value;
j0array[0]=((-1.0)*x1426);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1426)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x1428=IKcos(j0);
IkReal x1429=IKsin(j0);
IkReal x1430=(px*x1429);
IkReal x1431=((1.0)*x1428);
IkReal x1432=((1.0)*py*x1429);
evalcond[0]=(x1430+(((-1.0)*py*x1431)));
evalcond[1]=((((-1.0)*x1432))+(((-1.0)*px*x1431)));
evalcond[2]=(((cj2*py*x1428))+(((-1.0)*px*sj2*x1431))+(((-1.0)*cj2*x1430))+(((-1.0)*sj2*x1432)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x1433=((1.0)*px);
CheckValue<IkReal> x1435 = IKatan2WithCheck(IkReal((((cj2*py))+(((-1.0)*sj2*x1433)))),IkReal(((((-1.0)*cj2*x1433))+(((-1.0)*py*sj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1435.valid){
continue;
}
IkReal x1434=x1435.value;
j0array[0]=((-1.0)*x1434);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1434)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x1436=IKcos(j0);
IkReal x1437=IKsin(j0);
IkReal x1438=(px*x1437);
IkReal x1439=((1.0)*x1436);
IkReal x1440=((1.0)*py*x1437);
evalcond[0]=(x1438+(((-1.0)*py*x1439)));
evalcond[1]=((((-1.0)*px*x1439))+(((-1.0)*x1440)));
evalcond[2]=((((-1.0)*cj2*x1440))+((sj2*x1438))+(((-1.0)*py*sj2*x1439))+(((-1.0)*cj2*px*x1439)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1442 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1442.valid){
continue;
}
IkReal x1441=x1442.value;
j0array[0]=((-1.0)*x1441);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1441)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x1443=IKcos(j0);
IkReal x1444=IKsin(j0);
IkReal x1445=((1.0)*px);
IkReal x1446=(cj2*x1444);
IkReal x1447=(py*x1443);
IkReal x1448=((1.0)*py*x1444);
evalcond[0]=((((-1.0)*x1448))+(((-1.0)*x1443*x1445)));
evalcond[1]=((((-1.0)*x1445*x1446))+(((-1.0)*sj2*x1448))+(((-1.0)*sj2*x1443*x1445))+((cj2*x1447)));
evalcond[2]=((((-1.0)*cj2*x1443*x1445))+((px*sj2*x1444))+(((-1.0)*py*x1446))+(((-1.0)*sj2*x1447)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[4];
sj1=0;
cj1=1.0;
j1=0;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
IkReal x1449=pz*pz;
j0eval[0]=((((-1.0)*x1449))+pp);
j0eval[1]=4.0;
j0eval[2]=sj3;
j0eval[3]=IKsign(((((-5.0)*x1449))+(((5.0)*pp))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1451 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1451.valid){
continue;
}
IkReal x1450=x1451.value;
j0array[0]=((-1.0)*x1450);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1450)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1453 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1453.valid){
continue;
}
IkReal x1452=x1453.value;
j0array[0]=((-1.0)*x1452);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1452)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x1454 = IKatan2WithCheck(IkReal(((2.0)*px*sj3)),IkReal(((-2.0)*py*sj3)),IKFAST_ATAN2_MAGTHRESH);
if(!x1454.valid){
continue;
}
CheckValue<IkReal> x1455=IKPowWithIntegerCheck(IKsign(((((-5.0)*(pz*pz)))+(((5.0)*pp)))),-1);
if(!x1455.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1454.value)+(((1.5707963267949)*(x1455.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x1456=IKsin(j0);
IkReal x1457=IKcos(j0);
IkReal x1458=((1.0)*x1457);
evalcond[0]=((((-1.0)*px*x1458))+(((-1.0)*py*x1456)));
evalcond[1]=(((px*x1456))+(((-1.0)*py*x1458))+(((-0.4)*sj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[4];
sj1=0;
cj1=1.0;
j1=0;
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
IkReal x1459=pz*pz;
j0eval[0]=((((-1.0)*pp))+x1459);
j0eval[1]=4.0;
j0eval[2]=sj3;
j0eval[3]=IKsign(((((5.0)*x1459))+(((-5.0)*pp))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1461 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1461.valid){
continue;
}
IkReal x1460=x1461.value;
j0array[0]=((-1.0)*x1460);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1460)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1463 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1463.valid){
continue;
}
IkReal x1462=x1463.value;
j0array[0]=((-1.0)*x1462);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1462)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x1464 = IKatan2WithCheck(IkReal(((2.0)*px*sj3)),IkReal(((-2.0)*py*sj3)),IKFAST_ATAN2_MAGTHRESH);
if(!x1464.valid){
continue;
}
CheckValue<IkReal> x1465=IKPowWithIntegerCheck(IKsign(((((5.0)*(pz*pz)))+(((-5.0)*pp)))),-1);
if(!x1465.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1464.value)+(((1.5707963267949)*(x1465.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x1466=IKsin(j0);
IkReal x1467=IKcos(j0);
IkReal x1468=((1.0)*x1467);
evalcond[0]=((((-1.0)*py*x1466))+(((-1.0)*px*x1468)));
evalcond[1]=((((-1.0)*py*x1468))+((px*x1466))+(((0.4)*sj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1469=cj2*cj2;
IkReal x1470=((5.0)*sj2);
IkReal x1471=(cj2*sj2);
IkReal x1472=((2.0)*px*sj3);
IkReal x1473=((2.0)*py*sj3);
CheckValue<IkReal> x1474 = IKatan2WithCheck(IkReal((((x1471*x1473))+(((-1.0)*x1472))+((x1469*x1472)))),IkReal((((x1471*x1472))+(((-1.0)*x1469*x1473))+x1473)),IKFAST_ATAN2_MAGTHRESH);
if(!x1474.valid){
continue;
}
CheckValue<IkReal> x1475=IKPowWithIntegerCheck(IKsign(((((-1.0)*pp*x1470))+((x1470*(pz*pz))))),-1);
if(!x1475.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1474.value)+(((1.5707963267949)*(x1475.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[4];
IkReal x1476=IKcos(j0);
IkReal x1477=IKsin(j0);
IkReal x1478=((0.4)*sj3);
IkReal x1479=((1.0)*cj2);
IkReal x1480=(px*x1477);
IkReal x1481=((1.0)*x1476);
IkReal x1482=((1.0)*py*x1477);
evalcond[0]=((((-1.0)*sj2*x1478))+x1480+(((-1.0)*py*x1481)));
evalcond[1]=((((-1.0)*x1482))+(((-1.0)*px*x1481))+(((-1.0)*cj2*x1478)));
evalcond[2]=((((-1.0)*x1479*x1480))+((cj2*py*x1476))+(((-1.0)*px*sj2*x1481))+(((-1.0)*sj2*x1482)));
evalcond[3]=(((sj2*x1480))+(((-1.0)*py*sj2*x1481))+(((-1.0)*px*x1476*x1479))+(((-1.0)*x1478))+(((-1.0)*py*x1477*x1479)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1483=cj2*cj2;
IkReal x1484=(cj2*sj2);
IkReal x1485=((5.0)*cj2);
IkReal x1486=((2.0)*px*sj3);
IkReal x1487=((2.0)*py*sj3);
CheckValue<IkReal> x1488 = IKatan2WithCheck(IkReal(((((-1.0)*x1484*x1486))+((x1483*x1487)))),IkReal((((x1483*x1486))+((x1484*x1487)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1488.valid){
continue;
}
CheckValue<IkReal> x1489=IKPowWithIntegerCheck(IKsign(((((-1.0)*pp*x1485))+((x1485*(pz*pz))))),-1);
if(!x1489.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1488.value)+(((1.5707963267949)*(x1489.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[4];
IkReal x1490=IKcos(j0);
IkReal x1491=IKsin(j0);
IkReal x1492=((0.4)*sj3);
IkReal x1493=((1.0)*cj2);
IkReal x1494=(px*x1491);
IkReal x1495=((1.0)*x1490);
IkReal x1496=((1.0)*py*x1491);
evalcond[0]=((((-1.0)*sj2*x1492))+x1494+(((-1.0)*py*x1495)));
evalcond[1]=((((-1.0)*cj2*x1492))+(((-1.0)*x1496))+(((-1.0)*px*x1495)));
evalcond[2]=(((cj2*py*x1490))+(((-1.0)*x1493*x1494))+(((-1.0)*px*sj2*x1495))+(((-1.0)*sj2*x1496)));
evalcond[3]=(((sj2*x1494))+(((-1.0)*py*sj2*x1495))+(((-1.0)*x1492))+(((-1.0)*py*x1491*x1493))+(((-1.0)*px*x1490*x1493)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1497=((2.0)*sj3);
CheckValue<IkReal> x1498 = IKatan2WithCheck(IkReal((((px*sj2*x1497))+(((-1.0)*cj2*py*x1497)))),IkReal(((((-1.0)*py*sj2*x1497))+(((-1.0)*cj2*px*x1497)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1498.valid){
continue;
}
CheckValue<IkReal> x1499=IKPowWithIntegerCheck(IKsign(((((-5.0)*(pz*pz)))+(((5.0)*pp)))),-1);
if(!x1499.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1498.value)+(((1.5707963267949)*(x1499.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[4];
IkReal x1500=IKcos(j0);
IkReal x1501=IKsin(j0);
IkReal x1502=((0.4)*sj3);
IkReal x1503=((1.0)*cj2);
IkReal x1504=(px*x1501);
IkReal x1505=((1.0)*x1500);
IkReal x1506=((1.0)*py*x1501);
evalcond[0]=((((-1.0)*sj2*x1502))+x1504+(((-1.0)*py*x1505)));
evalcond[1]=((((-1.0)*x1506))+(((-1.0)*px*x1505))+(((-1.0)*cj2*x1502)));
evalcond[2]=((((-1.0)*sj2*x1506))+(((-1.0)*px*sj2*x1505))+(((-1.0)*x1503*x1504))+((cj2*py*x1500)));
evalcond[3]=((((-1.0)*py*sj2*x1505))+(((-1.0)*py*x1501*x1503))+(((-1.0)*x1502))+(((-1.0)*px*x1500*x1503))+((sj2*x1504)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x1507=pz*pz;
IkReal x1508=(px*sj3);
IkReal x1509=(py*sj3);
j0eval[0]=((((-1.0)*x1507))+pp);
j0eval[1]=IKsign(((((-5.0)*x1507))+(((5.0)*pp))));
j0eval[2]=((IKabs((((cj2*x1508))+(((-1.0)*sj2*x1509)))))+(IKabs((((cj2*x1509))+((sj2*x1508))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x1510=pz*pz;
IkReal x1511=cj2*cj2;
IkReal x1512=(px*sj3);
IkReal x1513=(cj2*sj2);
IkReal x1514=(cj2*pp);
IkReal x1515=(py*sj3);
IkReal x1516=(cj2*x1510);
j0eval[0]=((((-1.0)*x1516))+x1514);
j0eval[1]=IKsign(((((5.0)*x1514))+(((-5.0)*x1516))));
j0eval[2]=((IKabs((((x1511*x1515))+((x1512*x1513)))))+(IKabs(((((-1.0)*x1513*x1515))+((x1511*x1512))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x1517=cj2*cj2;
IkReal x1518=pz*pz;
IkReal x1519=((5.0)*sj2);
IkReal x1520=(px*sj3);
IkReal x1521=(cj2*sj2);
IkReal x1522=(py*sj3);
j0eval[0]=((((-1.0)*sj2*x1518))+((pp*sj2)));
j0eval[1]=((IKabs(((((-1.0)*x1517*x1520))+x1520+((x1521*x1522)))))+(IKabs((((x1517*x1522))+((x1520*x1521))+(((-1.0)*x1522))))));
j0eval[2]=IKsign(((((-1.0)*x1518*x1519))+((pp*x1519))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[4];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=0;
cj2=1.0;
j2=0;
IkReal x1523=pz*pz;
j0eval[0]=(pp+(((-1.0)*x1523)));
j0eval[1]=IKsign(((((-5.0)*x1523))+(((5.0)*pp))));
j0eval[2]=4.0;
j0eval[3]=sj3;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=0;
cj2=1.0;
j2=0;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1525 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1525.valid){
continue;
}
IkReal x1524=x1525.value;
j0array[0]=((-1.0)*x1524);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1524)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=0;
cj2=1.0;
j2=0;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1527 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1527.valid){
continue;
}
IkReal x1526=x1527.value;
j0array[0]=((-1.0)*x1526);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1526)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1528=((2.0)*sj3);
CheckValue<IkReal> x1529 = IKatan2WithCheck(IkReal((py*x1528)),IkReal((px*x1528)),IKFAST_ATAN2_MAGTHRESH);
if(!x1529.valid){
continue;
}
CheckValue<IkReal> x1530=IKPowWithIntegerCheck(IKsign(((((-5.0)*(pz*pz)))+(((5.0)*pp)))),-1);
if(!x1530.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1529.value)+(((1.5707963267949)*(x1530.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x1531=IKcos(j0);
IkReal x1532=IKsin(j0);
IkReal x1533=((1.0)*py);
evalcond[0]=((((-1.0)*x1531*x1533))+((px*x1532)));
evalcond[1]=((((-1.0)*x1532*x1533))+(((-1.0)*px*x1531))+(((0.4)*sj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[4];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
IkReal x1534=pz*pz;
j0eval[0]=((((-1.0)*pp))+x1534);
j0eval[1]=4.0;
j0eval[2]=sj3;
j0eval[3]=IKsign(((((5.0)*x1534))+(((-5.0)*pp))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1536 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1536.valid){
continue;
}
IkReal x1535=x1536.value;
j0array[0]=((-1.0)*x1535);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1535)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1538 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1538.valid){
continue;
}
IkReal x1537=x1538.value;
j0array[0]=((-1.0)*x1537);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1537)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1539=((2.0)*sj3);
CheckValue<IkReal> x1540=IKPowWithIntegerCheck(IKsign(((((5.0)*(pz*pz)))+(((-5.0)*pp)))),-1);
if(!x1540.valid){
continue;
}
CheckValue<IkReal> x1541 = IKatan2WithCheck(IkReal((py*x1539)),IkReal((px*x1539)),IKFAST_ATAN2_MAGTHRESH);
if(!x1541.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1540.value)))+(x1541.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x1542=IKcos(j0);
IkReal x1543=IKsin(j0);
IkReal x1544=((1.0)*py);
evalcond[0]=((((-1.0)*x1542*x1544))+((px*x1543)));
evalcond[1]=((((-1.0)*x1543*x1544))+(((-1.0)*px*x1542))+(((-0.4)*sj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs(((((-1.0)*cj2*px))+((py*sj2)))))+(IKabs((((cj2*py))+((px*sj2))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs((((cj2*px))+(((-1.0)*py*sj2)))))+(IKabs((((cj2*py))+((px*sj2))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1546 = IKatan2WithCheck(IkReal((((cj2*px))+(((-1.0)*py*sj2)))),IkReal((((cj2*py))+((px*sj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1546.valid){
continue;
}
IkReal x1545=x1546.value;
j0array[0]=((-1.0)*x1545);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1545)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x1547=IKcos(j0);
IkReal x1548=IKsin(j0);
IkReal x1549=(px*x1548);
IkReal x1550=((1.0)*x1547);
IkReal x1551=(py*x1548);
evalcond[0]=((((-1.0)*py*x1550))+x1549);
evalcond[1]=((((-1.0)*x1551))+(((-1.0)*px*x1550)));
evalcond[2]=(((cj2*py*x1547))+((px*sj2*x1547))+(((-1.0)*cj2*x1549))+((sj2*x1551)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1553 = IKatan2WithCheck(IkReal((((cj2*py))+((px*sj2)))),IkReal(((((-1.0)*cj2*px))+((py*sj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1553.valid){
continue;
}
IkReal x1552=x1553.value;
j0array[0]=((-1.0)*x1552);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1552)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x1554=IKcos(j0);
IkReal x1555=IKsin(j0);
IkReal x1556=(px*x1555);
IkReal x1557=((1.0)*x1554);
IkReal x1558=(py*x1555);
evalcond[0]=((((-1.0)*py*x1557))+x1556);
evalcond[1]=((((-1.0)*x1558))+(((-1.0)*px*x1557)));
evalcond[2]=(((cj2*x1558))+(((-1.0)*py*sj2*x1557))+((sj2*x1556))+((cj2*px*x1554)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1560 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1560.valid){
continue;
}
IkReal x1559=x1560.value;
j0array[0]=((-1.0)*x1559);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1559)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x1561=IKcos(j0);
IkReal x1562=IKsin(j0);
IkReal x1563=((1.0)*px);
IkReal x1564=(px*sj2);
IkReal x1565=(cj2*x1562);
IkReal x1566=(py*x1561);
IkReal x1567=(py*x1562);
evalcond[0]=((((-1.0)*x1567))+(((-1.0)*x1561*x1563)));
evalcond[1]=(((cj2*x1566))+((x1561*x1564))+(((-1.0)*x1563*x1565))+((sj2*x1567)));
evalcond[2]=((((-1.0)*sj2*x1566))+((cj2*px*x1561))+((x1562*x1564))+((py*x1565)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[4];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
IkReal x1568=pz*pz;
j0eval[0]=(pp+(((-1.0)*x1568)));
j0eval[1]=4.0;
j0eval[2]=sj3;
j0eval[3]=IKsign(((((-5.0)*x1568))+(((5.0)*pp))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1570 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1570.valid){
continue;
}
IkReal x1569=x1570.value;
j0array[0]=((-1.0)*x1569);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1569)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1572 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1572.valid){
continue;
}
IkReal x1571=x1572.value;
j0array[0]=((-1.0)*x1571);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1571)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x1573 = IKatan2WithCheck(IkReal(((2.0)*px*sj3)),IkReal(((-2.0)*py*sj3)),IKFAST_ATAN2_MAGTHRESH);
if(!x1573.valid){
continue;
}
CheckValue<IkReal> x1574=IKPowWithIntegerCheck(IKsign(((((-5.0)*(pz*pz)))+(((5.0)*pp)))),-1);
if(!x1574.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1573.value)+(((1.5707963267949)*(x1574.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x1575=IKsin(j0);
IkReal x1576=IKcos(j0);
IkReal x1577=((1.0)*x1576);
evalcond[0]=((((-1.0)*py*x1575))+(((-1.0)*px*x1577)));
evalcond[1]=((((-1.0)*py*x1577))+((px*x1575))+(((-0.4)*sj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[4];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
IkReal x1578=pz*pz;
j0eval[0]=((((-1.0)*pp))+x1578);
j0eval[1]=4.0;
j0eval[2]=sj3;
j0eval[3]=IKsign(((((5.0)*x1578))+(((-5.0)*pp))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1580 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1580.valid){
continue;
}
IkReal x1579=x1580.value;
j0array[0]=((-1.0)*x1579);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1579)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1582 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1582.valid){
continue;
}
IkReal x1581=x1582.value;
j0array[0]=((-1.0)*x1581);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1581)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x1583 = IKatan2WithCheck(IkReal(((2.0)*px*sj3)),IkReal(((-2.0)*py*sj3)),IKFAST_ATAN2_MAGTHRESH);
if(!x1583.valid){
continue;
}
CheckValue<IkReal> x1584=IKPowWithIntegerCheck(IKsign(((((5.0)*(pz*pz)))+(((-5.0)*pp)))),-1);
if(!x1584.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1583.value)+(((1.5707963267949)*(x1584.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x1585=IKsin(j0);
IkReal x1586=IKcos(j0);
IkReal x1587=((1.0)*x1586);
evalcond[0]=((((-1.0)*py*x1585))+(((-1.0)*px*x1587)));
evalcond[1]=((((-1.0)*py*x1587))+(((0.4)*sj3))+((px*x1585)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1588=cj2*cj2;
IkReal x1589=((5.0)*sj2);
IkReal x1590=(cj2*sj2);
IkReal x1591=((2.0)*px*sj3);
IkReal x1592=((2.0)*py*sj3);
CheckValue<IkReal> x1593 = IKatan2WithCheck(IkReal((((x1590*x1592))+(((-1.0)*x1588*x1591))+x1591)),IkReal(((((-1.0)*x1592))+((x1590*x1591))+((x1588*x1592)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1593.valid){
continue;
}
CheckValue<IkReal> x1594=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1589*(pz*pz)))+((pp*x1589)))),-1);
if(!x1594.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1593.value)+(((1.5707963267949)*(x1594.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[4];
IkReal x1595=IKcos(j0);
IkReal x1596=IKsin(j0);
IkReal x1597=((0.4)*sj3);
IkReal x1598=(cj2*py);
IkReal x1599=(px*x1596);
IkReal x1600=((1.0)*x1595);
IkReal x1601=(px*x1595);
IkReal x1602=(py*x1596);
evalcond[0]=((((-1.0)*py*x1600))+x1599+(((-1.0)*sj2*x1597)));
evalcond[1]=((((-1.0)*x1602))+((cj2*x1597))+(((-1.0)*px*x1600)));
evalcond[2]=(((sj2*x1601))+((sj2*x1602))+((x1595*x1598))+(((-1.0)*cj2*x1599)));
evalcond[3]=(((x1596*x1598))+(((-1.0)*x1597))+((sj2*x1599))+((cj2*x1601))+(((-1.0)*py*sj2*x1600)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1603=cj2*cj2;
IkReal x1604=(cj2*sj2);
IkReal x1605=((5.0)*cj2);
IkReal x1606=((2.0)*px*sj3);
IkReal x1607=((2.0)*py*sj3);
CheckValue<IkReal> x1608=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1605*(pz*pz)))+((pp*x1605)))),-1);
if(!x1608.valid){
continue;
}
CheckValue<IkReal> x1609 = IKatan2WithCheck(IkReal((((x1603*x1607))+((x1604*x1606)))),IkReal((((x1603*x1606))+(((-1.0)*x1604*x1607)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1609.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1608.value)))+(x1609.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[4];
IkReal x1610=IKcos(j0);
IkReal x1611=IKsin(j0);
IkReal x1612=((0.4)*sj3);
IkReal x1613=(cj2*py);
IkReal x1614=(px*x1611);
IkReal x1615=((1.0)*x1610);
IkReal x1616=(px*x1610);
IkReal x1617=(py*x1611);
evalcond[0]=(x1614+(((-1.0)*py*x1615))+(((-1.0)*sj2*x1612)));
evalcond[1]=((((-1.0)*x1617))+(((-1.0)*px*x1615))+((cj2*x1612)));
evalcond[2]=(((sj2*x1617))+((sj2*x1616))+(((-1.0)*cj2*x1614))+((x1610*x1613)));
evalcond[3]=(((sj2*x1614))+(((-1.0)*x1612))+((cj2*x1616))+(((-1.0)*py*sj2*x1615))+((x1611*x1613)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1618=((2.0)*sj3);
CheckValue<IkReal> x1619=IKPowWithIntegerCheck(IKsign(((((-5.0)*(pz*pz)))+(((5.0)*pp)))),-1);
if(!x1619.valid){
continue;
}
CheckValue<IkReal> x1620 = IKatan2WithCheck(IkReal((((cj2*py*x1618))+((px*sj2*x1618)))),IkReal((((cj2*px*x1618))+(((-1.0)*py*sj2*x1618)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1620.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1619.value)))+(x1620.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[4];
IkReal x1621=IKcos(j0);
IkReal x1622=IKsin(j0);
IkReal x1623=((0.4)*sj3);
IkReal x1624=(cj2*py);
IkReal x1625=(px*x1622);
IkReal x1626=((1.0)*x1621);
IkReal x1627=(px*x1621);
IkReal x1628=(py*x1622);
evalcond[0]=(x1625+(((-1.0)*py*x1626))+(((-1.0)*sj2*x1623)));
evalcond[1]=((((-1.0)*x1628))+(((-1.0)*px*x1626))+((cj2*x1623)));
evalcond[2]=(((sj2*x1627))+((sj2*x1628))+(((-1.0)*cj2*x1625))+((x1621*x1624)));
evalcond[3]=(((sj2*x1625))+((x1622*x1624))+(((-1.0)*x1623))+((cj2*x1627))+(((-1.0)*py*sj2*x1626)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1629=((2.0)*px);
IkReal x1630=((2.0)*py);
IkReal x1631=(sj2*sj3);
IkReal x1632=(cj3*sj1);
IkReal x1633=(cj1*cj2*sj3);
CheckValue<IkReal> x1634 = IKatan2WithCheck(IkReal((((sj1*x1630))+((x1629*x1631))+(((-1.0)*x1630*x1633))+((x1630*x1632)))),IkReal((((sj1*x1629))+((x1629*x1632))+(((-1.0)*x1629*x1633))+(((-1.0)*x1630*x1631)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1634.valid){
continue;
}
CheckValue<IkReal> x1635=IKPowWithIntegerCheck(IKsign(((((-5.0)*(pz*pz)))+(((5.0)*pp)))),-1);
if(!x1635.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1634.value)+(((1.5707963267949)*(x1635.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[6];
IkReal x1636=IKcos(j0);
IkReal x1637=IKsin(j0);
IkReal x1638=(pz*sj1);
IkReal x1639=((0.4)*cj3);
IkReal x1640=((1.0)*cj2);
IkReal x1641=((1.0)*cj1);
IkReal x1642=((0.4)*sj3);
IkReal x1643=(cj1*cj2);
IkReal x1644=((0.8)*sj1);
IkReal x1645=(px*x1637);
IkReal x1646=((1.0)*x1636);
IkReal x1647=(py*x1637);
evalcond[0]=((((-1.0)*py*x1646))+(((-1.0)*sj2*x1642))+x1645);
evalcond[1]=(((x1644*x1647))+(((-1.0)*pp))+((px*x1636*x1644))+(((0.8)*cj1*pz)));
evalcond[2]=((0.4)+x1639+(((-1.0)*px*sj1*x1646))+(((-1.0)*sj1*x1647))+(((-1.0)*pz*x1641)));
evalcond[3]=(((sj1*x1639))+(((-1.0)*px*x1646))+(((-1.0)*x1642*x1643))+(((-1.0)*x1647))+(((0.4)*sj1)));
evalcond[4]=(((sj2*x1638))+(((-1.0)*x1640*x1645))+(((-1.0)*sj2*x1641*x1647))+(((-1.0)*px*sj2*x1636*x1641))+((cj2*py*x1636)));
evalcond[5]=(((cj2*x1638))+(((-1.0)*py*sj2*x1646))+((sj2*x1645))+(((-1.0)*cj1*px*x1636*x1640))+(((-1.0)*x1642))+(((-1.0)*cj1*x1640*x1647)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1648=((2.0)*px);
IkReal x1649=((5.0)*sj1);
IkReal x1650=((2.0)*py);
IkReal x1651=((5.0)*cj1*pz);
IkReal x1652=(sj1*sj2*sj3);
CheckValue<IkReal> x1653=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1649*(pz*pz)))+((pp*x1649)))),-1);
if(!x1653.valid){
continue;
}
CheckValue<IkReal> x1654 = IKatan2WithCheck(IkReal(((((-1.0)*py*x1651))+((x1648*x1652))+x1650+((cj3*x1650)))),IkReal((((cj3*x1648))+x1648+(((-1.0)*px*x1651))+(((-1.0)*x1650*x1652)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1654.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1653.value)))+(x1654.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[6];
IkReal x1655=IKcos(j0);
IkReal x1656=IKsin(j0);
IkReal x1657=(pz*sj1);
IkReal x1658=((0.4)*cj3);
IkReal x1659=((1.0)*cj2);
IkReal x1660=((1.0)*cj1);
IkReal x1661=((0.4)*sj3);
IkReal x1662=(cj1*cj2);
IkReal x1663=((0.8)*sj1);
IkReal x1664=(px*x1656);
IkReal x1665=((1.0)*x1655);
IkReal x1666=(py*x1656);
evalcond[0]=((((-1.0)*py*x1665))+(((-1.0)*sj2*x1661))+x1664);
evalcond[1]=((((-1.0)*pp))+(((0.8)*cj1*pz))+((x1663*x1666))+((px*x1655*x1663)));
evalcond[2]=((0.4)+(((-1.0)*pz*x1660))+x1658+(((-1.0)*px*sj1*x1665))+(((-1.0)*sj1*x1666)));
evalcond[3]=(((sj1*x1658))+(((-1.0)*x1661*x1662))+(((-1.0)*x1666))+(((-1.0)*px*x1665))+(((0.4)*sj1)));
evalcond[4]=(((cj2*py*x1655))+(((-1.0)*sj2*x1660*x1666))+((sj2*x1657))+(((-1.0)*px*sj2*x1655*x1660))+(((-1.0)*x1659*x1664)));
evalcond[5]=((((-1.0)*cj1*px*x1655*x1659))+(((-1.0)*py*sj2*x1665))+((cj2*x1657))+((sj2*x1664))+(((-1.0)*x1661))+(((-1.0)*cj1*x1659*x1666)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1667=((20.0)*sj1);
IkReal x1668=((25.0)*pp);
IkReal x1669=((20.0)*cj1*pz);
IkReal x1670=((8.0)*sj1*sj2*sj3);
CheckValue<IkReal> x1671=IKPowWithIntegerCheck(IKsign((((pp*x1667))+(((-1.0)*x1667*(pz*pz))))),-1);
if(!x1671.valid){
continue;
}
CheckValue<IkReal> x1672 = IKatan2WithCheck(IkReal(((((-1.0)*py*x1669))+((px*x1670))+((py*x1668)))),IkReal((((px*x1668))+(((-1.0)*px*x1669))+(((-1.0)*py*x1670)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1672.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1671.value)))+(x1672.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[6];
IkReal x1673=IKcos(j0);
IkReal x1674=IKsin(j0);
IkReal x1675=(pz*sj1);
IkReal x1676=((0.4)*cj3);
IkReal x1677=((1.0)*cj2);
IkReal x1678=((1.0)*cj1);
IkReal x1679=((0.4)*sj3);
IkReal x1680=(cj1*cj2);
IkReal x1681=((0.8)*sj1);
IkReal x1682=(px*x1674);
IkReal x1683=((1.0)*x1673);
IkReal x1684=(py*x1674);
evalcond[0]=((((-1.0)*py*x1683))+(((-1.0)*sj2*x1679))+x1682);
evalcond[1]=(((x1681*x1684))+((px*x1673*x1681))+(((-1.0)*pp))+(((0.8)*cj1*pz)));
evalcond[2]=((0.4)+x1676+(((-1.0)*sj1*x1684))+(((-1.0)*px*sj1*x1683))+(((-1.0)*pz*x1678)));
evalcond[3]=(((sj1*x1676))+(((-1.0)*x1684))+(((-1.0)*x1679*x1680))+(((0.4)*sj1))+(((-1.0)*px*x1683)));
evalcond[4]=((((-1.0)*x1677*x1682))+(((-1.0)*sj2*x1678*x1684))+((sj2*x1675))+(((-1.0)*px*sj2*x1673*x1678))+((cj2*py*x1673)));
evalcond[5]=(((cj2*x1675))+(((-1.0)*py*sj2*x1683))+(((-1.0)*cj1*px*x1673*x1677))+(((-1.0)*cj1*x1677*x1684))+(((-1.0)*x1679))+((sj2*x1682)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1687 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x1687.valid){
continue;
}
IkReal x1685=((1.0)*(x1687.value));
if((((px*px)+(py*py))) < -0.00001)
continue;
CheckValue<IkReal> x1688=IKPowWithIntegerCheck(IKabs(IKsqrt(((px*px)+(py*py)))),-1);
if(!x1688.valid){
continue;
}
if( (((0.4)*sj2*sj3*(x1688.value))) < -1-IKFAST_SINCOS_THRESH || (((0.4)*sj2*sj3*(x1688.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1686=IKasin(((0.4)*sj2*sj3*(x1688.value)));
j0array[0]=((((-1.0)*x1685))+x1686);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1685))+(((-1.0)*x1686)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j1eval[3];
IkReal x1689=(py*sj0);
IkReal x1690=((8.0)*cj3);
IkReal x1691=((20.0)*pz);
IkReal x1692=(cj0*px);
IkReal x1693=((10.0)*pp);
IkReal x1694=((1.0)*cj3);
IkReal x1695=(cj2*sj3);
j1eval[0]=((((-1.0)*x1692*x1694))+(((-1.0)*x1692))+(((-1.0)*x1689))+((pz*x1695))+(((-1.0)*x1689*x1694)));
j1eval[1]=((IKabs(((((-1.0)*x1691*x1692))+((x1693*x1695))+(((-1.0)*x1689*x1691)))))+(IKabs(((((-1.0)*x1693))+((pz*x1691))+(((-1.0)*cj3*x1693))))));
j1eval[2]=IKsign(((((8.0)*pz*x1695))+(((-1.0)*x1690*x1692))+(((-8.0)*x1689))+(((-8.0)*x1692))+(((-1.0)*x1689*x1690))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
IkReal x1696=((2.0)*cj3);
IkReal x1697=(py*sj0);
IkReal x1698=(cj0*px);
IkReal x1699=(cj2*sj3);
IkReal x1700=((5.0)*pz);
IkReal x1701=((1.0)*cj3);
j1eval[0]=((((-1.0)*x1698*x1701))+(((-1.0)*x1698))+(((-1.0)*x1697))+((pz*x1699))+(((-1.0)*x1697*x1701)));
j1eval[1]=((IKabs(((((-1.0)*x1698*x1700))+(((0.8)*x1699))+(((0.8)*cj3*x1699))+(((-1.0)*x1697*x1700)))))+(IKabs(((-0.8)+(((-1.6)*cj3))+((pz*x1700))+(((-0.8)*(cj3*cj3)))))));
j1eval[2]=IKsign(((((-1.0)*x1696*x1698))+(((-1.0)*x1696*x1697))+(((2.0)*pz*x1699))+(((-2.0)*x1697))+(((-2.0)*x1698))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
IkReal x1702=cj2*cj2;
IkReal x1703=cj3*cj3;
IkReal x1704=((10.0)*cj3);
IkReal x1705=(py*sj0);
IkReal x1706=(cj0*px);
IkReal x1707=((10.0)*cj2*sj3);
IkReal x1708=(x1702*x1703);
j1eval[0]=((1.0)+x1702+x1703+(((-1.0)*x1708))+(((2.0)*cj3)));
j1eval[1]=IKsign(((4.0)+(((8.0)*cj3))+(((-4.0)*x1708))+(((4.0)*x1703))+(((4.0)*x1702))));
j1eval[2]=((IKabs(((((10.0)*x1706))+(((10.0)*x1705))+((x1704*x1705))+((x1704*x1706))+((pz*x1707)))))+(IKabs(((((10.0)*pz))+(((-1.0)*x1705*x1707))+(((-1.0)*x1706*x1707))+((pz*x1704))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1709=cj2*cj2;
IkReal x1710=cj3*cj3;
IkReal x1711=((10.0)*cj3);
IkReal x1712=(py*sj0);
IkReal x1713=(cj0*px);
IkReal x1714=((4.0)*x1710);
IkReal x1715=((10.0)*cj2*sj3);
CheckValue<IkReal> x1716 = IKatan2WithCheck(IkReal((((x1711*x1713))+((x1711*x1712))+(((10.0)*x1713))+(((10.0)*x1712))+((pz*x1715)))),IkReal(((((-1.0)*x1712*x1715))+(((-1.0)*x1713*x1715))+(((10.0)*pz))+((pz*x1711)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1716.valid){
continue;
}
CheckValue<IkReal> x1717=IKPowWithIntegerCheck(IKsign(((4.0)+(((8.0)*cj3))+x1714+(((-1.0)*x1709*x1714))+(((4.0)*x1709)))),-1);
if(!x1717.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1716.value)+(((1.5707963267949)*(x1717.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1718=IKcos(j1);
IkReal x1719=IKsin(j1);
IkReal x1720=(px*sj0);
IkReal x1721=((0.4)*cj3);
IkReal x1722=((1.0)*cj2);
IkReal x1723=((0.4)*sj3);
IkReal x1724=(py*sj0);
IkReal x1725=(cj0*py);
IkReal x1726=((1.0)*cj0*px);
IkReal x1727=((1.0)*x1718);
IkReal x1728=(cj2*x1719);
IkReal x1729=((0.8)*x1719);
IkReal x1730=(cj2*x1718);
evalcond[0]=((((-0.4)*x1718))+(((-1.0)*x1723*x1728))+pz+(((-1.0)*x1718*x1721)));
evalcond[1]=(((x1724*x1729))+(((0.8)*pz*x1718))+(((-1.0)*pp))+((cj0*px*x1729)));
evalcond[2]=((0.4)+(((-1.0)*x1719*x1724))+x1721+(((-1.0)*pz*x1727))+(((-1.0)*x1719*x1726)));
evalcond[3]=((((-1.0)*x1723*x1730))+(((-1.0)*x1724))+(((-1.0)*x1726))+((x1719*x1721))+(((0.4)*x1719)));
evalcond[4]=((((-1.0)*sj2*x1724*x1727))+((cj2*x1725))+(((-1.0)*x1720*x1722))+((pz*sj2*x1719))+(((-1.0)*sj2*x1718*x1726)));
evalcond[5]=((((-1.0)*sj2*x1725))+((pz*x1728))+(((-1.0)*x1718*x1722*x1724))+(((-1.0)*x1723))+((sj2*x1720))+(((-1.0)*cj0*px*x1718*x1722)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1731=((2.0)*cj3);
IkReal x1732=(py*sj0);
IkReal x1733=(cj0*px);
IkReal x1734=(cj2*sj3);
IkReal x1735=((5.0)*pz);
CheckValue<IkReal> x1736=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1731*x1732))+(((-1.0)*x1731*x1733))+(((-2.0)*x1733))+(((-2.0)*x1732))+(((2.0)*pz*x1734)))),-1);
if(!x1736.valid){
continue;
}
CheckValue<IkReal> x1737 = IKatan2WithCheck(IkReal(((-0.8)+((pz*x1735))+(((-1.6)*cj3))+(((-0.8)*(cj3*cj3))))),IkReal(((((-1.0)*x1733*x1735))+(((0.8)*cj3*x1734))+(((0.8)*x1734))+(((-1.0)*x1732*x1735)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1737.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1736.value)))+(x1737.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1738=IKcos(j1);
IkReal x1739=IKsin(j1);
IkReal x1740=(px*sj0);
IkReal x1741=((0.4)*cj3);
IkReal x1742=((1.0)*cj2);
IkReal x1743=((0.4)*sj3);
IkReal x1744=(py*sj0);
IkReal x1745=(cj0*py);
IkReal x1746=((1.0)*cj0*px);
IkReal x1747=((1.0)*x1738);
IkReal x1748=(cj2*x1739);
IkReal x1749=((0.8)*x1739);
IkReal x1750=(cj2*x1738);
evalcond[0]=((((-1.0)*x1738*x1741))+pz+(((-0.4)*x1738))+(((-1.0)*x1743*x1748)));
evalcond[1]=(((x1744*x1749))+(((-1.0)*pp))+(((0.8)*pz*x1738))+((cj0*px*x1749)));
evalcond[2]=((0.4)+x1741+(((-1.0)*x1739*x1744))+(((-1.0)*x1739*x1746))+(((-1.0)*pz*x1747)));
evalcond[3]=(((x1739*x1741))+(((0.4)*x1739))+(((-1.0)*x1744))+(((-1.0)*x1746))+(((-1.0)*x1743*x1750)));
evalcond[4]=((((-1.0)*x1740*x1742))+((pz*sj2*x1739))+((cj2*x1745))+(((-1.0)*sj2*x1738*x1746))+(((-1.0)*sj2*x1744*x1747)));
evalcond[5]=(((pz*x1748))+(((-1.0)*cj0*px*x1738*x1742))+(((-1.0)*sj2*x1745))+(((-1.0)*x1743))+(((-1.0)*x1738*x1742*x1744))+((sj2*x1740)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1751=(py*sj0);
IkReal x1752=((8.0)*cj3);
IkReal x1753=((20.0)*pz);
IkReal x1754=(cj0*px);
IkReal x1755=((10.0)*pp);
IkReal x1756=(cj2*sj3);
CheckValue<IkReal> x1757 = IKatan2WithCheck(IkReal((((pz*x1753))+(((-1.0)*x1755))+(((-1.0)*cj3*x1755)))),IkReal(((((-1.0)*x1751*x1753))+(((-1.0)*x1753*x1754))+((x1755*x1756)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1757.valid){
continue;
}
CheckValue<IkReal> x1758=IKPowWithIntegerCheck(IKsign(((((8.0)*pz*x1756))+(((-8.0)*x1751))+(((-8.0)*x1754))+(((-1.0)*x1751*x1752))+(((-1.0)*x1752*x1754)))),-1);
if(!x1758.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1757.value)+(((1.5707963267949)*(x1758.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1759=IKcos(j1);
IkReal x1760=IKsin(j1);
IkReal x1761=(px*sj0);
IkReal x1762=((0.4)*cj3);
IkReal x1763=((1.0)*cj2);
IkReal x1764=((0.4)*sj3);
IkReal x1765=(py*sj0);
IkReal x1766=(cj0*py);
IkReal x1767=((1.0)*cj0*px);
IkReal x1768=((1.0)*x1759);
IkReal x1769=(cj2*x1760);
IkReal x1770=((0.8)*x1760);
IkReal x1771=(cj2*x1759);
evalcond[0]=((((-0.4)*x1759))+(((-1.0)*x1759*x1762))+pz+(((-1.0)*x1764*x1769)));
evalcond[1]=(((x1765*x1770))+((cj0*px*x1770))+(((-1.0)*pp))+(((0.8)*pz*x1759)));
evalcond[2]=((0.4)+(((-1.0)*pz*x1768))+x1762+(((-1.0)*x1760*x1767))+(((-1.0)*x1760*x1765)));
evalcond[3]=((((-1.0)*x1765))+(((0.4)*x1760))+(((-1.0)*x1767))+(((-1.0)*x1764*x1771))+((x1760*x1762)));
evalcond[4]=(((pz*sj2*x1760))+(((-1.0)*sj2*x1765*x1768))+(((-1.0)*sj2*x1759*x1767))+(((-1.0)*x1761*x1763))+((cj2*x1766)));
evalcond[5]=((((-1.0)*x1764))+((sj2*x1761))+(((-1.0)*cj0*px*x1759*x1763))+((pz*x1769))+(((-1.0)*x1759*x1763*x1765))+(((-1.0)*sj2*x1766)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
}
}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x102=((1.0)*cj3);
IkReal x103=(sj0*sj2);
IkReal x104=(cj2*sj1);
IkReal x105=(cj1*cj3);
IkReal x106=(cj0*sj2);
IkReal x107=(sj1*sj2);
IkReal x108=(cj1*sj3);
IkReal x109=((1.0)*cj2);
IkReal x110=((1.0)*cj1);
IkReal x111=(sj3*x106);
IkReal x112=(((cj2*x105))+((sj1*sj3)));
IkReal x113=(x108+(((-1.0)*x102*x104)));
IkReal x114=(((cj0*cj2))+(((-1.0)*x103*x110)));
IkReal x115=((((-1.0)*x108*x109))+((cj3*sj1)));
IkReal x116=(((sj3*x104))+x105);
IkReal x117=(sj0*x115);
IkReal x118=((((-1.0)*x106*x110))+(((-1.0)*sj0*x109)));
IkReal x119=(((sj0*x112))+((cj3*x106)));
IkReal x120=(((cj0*x112))+(((-1.0)*x102*x103)));
IkReal x121=(((sj3*x103))+((cj0*x115)));
IkReal x122=(x117+(((-1.0)*x111)));
new_r00=(((r10*x119))+((r00*x120))+((r20*x113)));
new_r01=(((r01*x120))+((r21*x113))+((r11*x119)));
new_r02=(((r22*x113))+((r02*x120))+((r12*x119)));
new_r10=(((r10*x114))+((r20*x107))+((r00*x118)));
new_r11=(((r21*x107))+((r11*x114))+((r01*x118)));
new_r12=(((r02*x118))+((r22*x107))+((r12*x114)));
new_r20=(((r00*x121))+((r20*x116))+((r10*x122)));
new_r21=(((r01*x121))+((r21*x116))+((r11*((x117+(((-1.0)*x111)))))));
new_r22=(((r22*x116))+((r02*x121))+((r12*x122)));
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
cj5array[0]=new_r22;
if( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKacos(cj5array[0]);
    sj5array[0] = IKsin(j5array[0]);
    cj5array[1] = cj5array[0];
    j5array[1] = -j5array[0];
    sj5array[1] = -sj5array[0];
}
else if( isnan(cj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j4eval[3];
j4eval[0]=sj5;
j4eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j4eval[2]=IKsign(sj5);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
j6eval[0]=sj5;
j6eval[1]=IKsign(sj5);
j6eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=new_r12;
j4eval[1]=sj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j6mul = 1;
j6=0;
j4mul=-1.0;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r00));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].fmul = j4mul;
vinfos[4].freeind = 0;
vinfos[4].maxsolutions = 0;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].fmul = j6mul;
vinfos[6].freeind = 0;
vinfos[6].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 6;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j6mul = 1;
j6=0;
j4mul=1.0;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4=IKatan2(new_r10, ((-1.0)*new_r11));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].fmul = j4mul;
vinfos[4].freeind = 0;
vinfos[4].maxsolutions = 0;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].fmul = j6mul;
vinfos[6].freeind = 0;
vinfos[6].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 6;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x123=new_r22*new_r22;
IkReal x124=((16.0)*new_r10);
IkReal x125=((16.0)*new_r01);
IkReal x126=((16.0)*new_r22);
IkReal x127=((8.0)*new_r11);
IkReal x128=((8.0)*new_r00);
IkReal x129=(x123*x124);
IkReal x130=(x123*x125);
j4eval[0]=((IKabs(((((32.0)*new_r11))+(((-1.0)*new_r00*x126))+(((-16.0)*new_r11*x123)))))+(IKabs(((((-1.0)*x129))+x124)))+(IKabs(((((-1.0)*x124))+x129)))+(IKabs(((((-1.0)*x125))+x130)))+(IKabs(((((16.0)*new_r00))+(((-32.0)*new_r00*x123))+((new_r11*x126)))))+(IKabs((((new_r22*x127))+(((-1.0)*x128)))))+(IKabs((((x123*x127))+(((-1.0)*new_r22*x128)))))+(IKabs((x125+(((-1.0)*x130))))));
if( IKabs(j4eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j4, j6]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j4evalpoly[1];
IkReal x131=new_r22*new_r22;
IkReal x132=((16.0)*new_r10);
IkReal x133=(new_r11*new_r22);
IkReal x134=(x131*x132);
IkReal x135=((((-8.0)*new_r00))+(((8.0)*x133)));
op[0]=x135;
op[1]=(x132+(((-1.0)*x134)));
op[2]=((((16.0)*x133))+(((16.0)*new_r00))+(((-32.0)*new_r00*x131)));
op[3]=(x134+(((-1.0)*x132)));
op[4]=x135;
polyroots4(op,zeror,numroots);
IkReal j4array[4], cj4array[4], sj4array[4], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[4]={true,true,true,true};
_nj4 = 4;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

IkReal x136=new_r22*new_r22;
IkReal x137=((16.0)*new_r01);
IkReal x138=(new_r00*new_r22);
IkReal x139=((8.0)*x138);
IkReal x140=(new_r11*x136);
IkReal x141=(x136*x137);
IkReal x142=((8.0)*x140);
j4evalpoly[0]=((((htj4*htj4)*(((((32.0)*new_r11))+(((-16.0)*x140))+(((-16.0)*x138))))))+(((htj4*htj4*htj4)*((x141+(((-1.0)*x137))))))+x142+(((-1.0)*x139))+(((htj4*htj4*htj4*htj4)*((x142+(((-1.0)*x139))))))+((htj4*(((((-1.0)*x141))+x137)))));
if( IKabs(j4evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
IkReal j6eval[3];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x143=cj4*cj4;
IkReal x144=new_r22*new_r22;
IkReal x145=((1.0)*cj4);
IkReal x146=(new_r22*sj4);
IkReal x147=((((-1.0)*x143*x144))+x143+x144);
j6eval[0]=x147;
j6eval[1]=((IKabs((((new_r11*x146))+(((-1.0)*new_r10*x145)))))+(IKabs(((((-1.0)*new_r11*x145))+(((-1.0)*new_r10*x146))))));
j6eval[2]=IKsign(x147);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j6eval[0]=new_r22;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j6eval[0]=cj4;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r00, new_r01);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x148=IKsin(j6);
IkReal x149=IKcos(j6);
evalcond[0]=x148;
evalcond[1]=((-1.0)*x149);
evalcond[2]=(x148+(((-1.0)*new_r00)));
evalcond[3]=(x149+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x150=IKsin(j6);
IkReal x151=IKcos(j6);
evalcond[0]=x150;
evalcond[1]=(x150+new_r00);
evalcond[2]=(x151+new_r01);
evalcond[3]=((-1.0)*x151);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x152=new_r22*new_r22;
CheckValue<IkReal> x153=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x152))),-1);
if(!x153.valid){
continue;
}
if((((-1.0)*x152*(x153.value))) < -0.00001)
continue;
IkReal gconst12=IKsqrt(((-1.0)*x152*(x153.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.0)+(IKsign(sj4)))))+(IKabs((cj4+(((-1.0)*gconst12)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
IkReal x154=new_r22*new_r22;
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst12*gconst12))))) < -0.00001)
continue;
sj4=IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12)))));
cj4=gconst12;
if( (gconst12) < -1-IKFAST_SINCOS_THRESH || (gconst12) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=IKacos(gconst12);
CheckValue<IkReal> x155=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x154))),-1);
if(!x155.valid){
continue;
}
if((((-1.0)*x154*(x155.value))) < -0.00001)
continue;
IkReal gconst12=IKsqrt(((-1.0)*x154*(x155.value)));
j6eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x156=IKPowWithIntegerCheck(gconst12,-1);
if(!x156.valid){
continue;
}
if((((1.0)+(((-1.0)*(gconst12*gconst12))))) < -0.00001)
continue;
if( IKabs(((-1.0)*new_r10*(x156.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12))))))))+(((-1.0)*gconst12*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10*(x156.value)))+IKsqr((((new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12))))))))+(((-1.0)*gconst12*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10*(x156.value)), (((new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12))))))))+(((-1.0)*gconst12*new_r11))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x157=IKsin(j6);
IkReal x158=IKcos(j6);
if((((1.0)+(((-1.0)*(gconst12*gconst12))))) < -0.00001)
continue;
IkReal x159=IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12)))));
IkReal x160=((1.0)*x159);
evalcond[0]=x157;
evalcond[1]=((-1.0)*x158);
evalcond[2]=(((gconst12*x157))+new_r10);
evalcond[3]=(((gconst12*x158))+new_r11);
evalcond[4]=((((-1.0)*x157*x160))+new_r00);
evalcond[5]=((((-1.0)*x158*x160))+new_r01);
evalcond[6]=((((-1.0)*new_r00*x160))+x157+((gconst12*new_r10)));
evalcond[7]=(x158+(((-1.0)*new_r01*x160))+((gconst12*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x161 = IKatan2WithCheck(IkReal(((-1.0)*new_r10)),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x161.valid){
continue;
}
CheckValue<IkReal> x162=IKPowWithIntegerCheck(IKsign(gconst12),-1);
if(!x162.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x161.value)+(((1.5707963267949)*(x162.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x163=IKsin(j6);
IkReal x164=IKcos(j6);
if((((1.0)+(((-1.0)*(gconst12*gconst12))))) < -0.00001)
continue;
IkReal x165=IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12)))));
IkReal x166=((1.0)*x165);
evalcond[0]=x163;
evalcond[1]=((-1.0)*x164);
evalcond[2]=(((gconst12*x163))+new_r10);
evalcond[3]=(((gconst12*x164))+new_r11);
evalcond[4]=((((-1.0)*x163*x166))+new_r00);
evalcond[5]=(new_r01+(((-1.0)*x164*x166)));
evalcond[6]=((((-1.0)*new_r00*x166))+x163+((gconst12*new_r10)));
evalcond[7]=(x164+(((-1.0)*new_r01*x166))+((gconst12*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x167=new_r22*new_r22;
CheckValue<IkReal> x168=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x167))),-1);
if(!x168.valid){
continue;
}
if((((-1.0)*x167*(x168.value))) < -0.00001)
continue;
IkReal gconst12=IKsqrt(((-1.0)*x167*(x168.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj4+(((-1.0)*gconst12)))))+(IKabs(((1.0)+(IKsign(sj4)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
IkReal x169=new_r22*new_r22;
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst12*gconst12))))) < -0.00001)
continue;
sj4=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12)))))));
cj4=gconst12;
if( (gconst12) < -1-IKFAST_SINCOS_THRESH || (gconst12) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=((-1.0)*(IKacos(gconst12)));
CheckValue<IkReal> x170=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x169))),-1);
if(!x170.valid){
continue;
}
if((((-1.0)*x169*(x170.value))) < -0.00001)
continue;
IkReal gconst12=IKsqrt(((-1.0)*x169*(x170.value)));
j6eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x171=IKPowWithIntegerCheck(gconst12,-1);
if(!x171.valid){
continue;
}
if((((1.0)+(((-1.0)*(gconst12*gconst12))))) < -0.00001)
continue;
if( IKabs(((-1.0)*new_r10*(x171.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12))))))))+(((-1.0)*gconst12*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10*(x171.value)))+IKsqr(((((-1.0)*new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12))))))))+(((-1.0)*gconst12*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10*(x171.value)), ((((-1.0)*new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12))))))))+(((-1.0)*gconst12*new_r11))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x172=IKsin(j6);
IkReal x173=IKcos(j6);
if((((1.0)+(((-1.0)*(gconst12*gconst12))))) < -0.00001)
continue;
IkReal x174=IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12)))));
evalcond[0]=x172;
evalcond[1]=((-1.0)*x173);
evalcond[2]=(((gconst12*x172))+new_r10);
evalcond[3]=(((gconst12*x173))+new_r11);
evalcond[4]=(((x172*x174))+new_r00);
evalcond[5]=(((x173*x174))+new_r01);
evalcond[6]=(((new_r00*x174))+x172+((gconst12*new_r10)));
evalcond[7]=(((new_r01*x174))+x173+((gconst12*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x175 = IKatan2WithCheck(IkReal(((-1.0)*new_r10)),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x175.valid){
continue;
}
CheckValue<IkReal> x176=IKPowWithIntegerCheck(IKsign(gconst12),-1);
if(!x176.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x175.value)+(((1.5707963267949)*(x176.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x177=IKsin(j6);
IkReal x178=IKcos(j6);
if((((1.0)+(((-1.0)*(gconst12*gconst12))))) < -0.00001)
continue;
IkReal x179=IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12)))));
evalcond[0]=x177;
evalcond[1]=((-1.0)*x178);
evalcond[2]=(((gconst12*x177))+new_r10);
evalcond[3]=(((gconst12*x178))+new_r11);
evalcond[4]=(new_r00+((x177*x179)));
evalcond[5]=(((x178*x179))+new_r01);
evalcond[6]=(((new_r00*x179))+x177+((gconst12*new_r10)));
evalcond[7]=(((new_r01*x179))+x178+((gconst12*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x180=new_r22*new_r22;
CheckValue<IkReal> x181=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x180))),-1);
if(!x181.valid){
continue;
}
if((((-1.0)*x180*(x181.value))) < -0.00001)
continue;
IkReal gconst13=((-1.0)*(IKsqrt(((-1.0)*x180*(x181.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.0)+(IKsign(sj4)))))+(IKabs((cj4+(((-1.0)*gconst13)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
IkReal x182=new_r22*new_r22;
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst13*gconst13))))) < -0.00001)
continue;
sj4=IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13)))));
cj4=gconst13;
if( (gconst13) < -1-IKFAST_SINCOS_THRESH || (gconst13) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=IKacos(gconst13);
CheckValue<IkReal> x183=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x182))),-1);
if(!x183.valid){
continue;
}
if((((-1.0)*x182*(x183.value))) < -0.00001)
continue;
IkReal gconst13=((-1.0)*(IKsqrt(((-1.0)*x182*(x183.value)))));
j6eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x184=IKPowWithIntegerCheck(gconst13,-1);
if(!x184.valid){
continue;
}
if((((1.0)+(((-1.0)*(gconst13*gconst13))))) < -0.00001)
continue;
if( IKabs(((-1.0)*new_r10*(x184.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*gconst13*new_r11))+((new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10*(x184.value)))+IKsqr(((((-1.0)*gconst13*new_r11))+((new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13))))))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10*(x184.value)), ((((-1.0)*gconst13*new_r11))+((new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13))))))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x185=IKsin(j6);
IkReal x186=IKcos(j6);
if((((1.0)+(((-1.0)*(gconst13*gconst13))))) < -0.00001)
continue;
IkReal x187=IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13)))));
IkReal x188=((1.0)*x187);
evalcond[0]=x185;
evalcond[1]=((-1.0)*x186);
evalcond[2]=(((gconst13*x185))+new_r10);
evalcond[3]=(((gconst13*x186))+new_r11);
evalcond[4]=((((-1.0)*x185*x188))+new_r00);
evalcond[5]=((((-1.0)*x186*x188))+new_r01);
evalcond[6]=(x185+((gconst13*new_r10))+(((-1.0)*new_r00*x188)));
evalcond[7]=(x186+((gconst13*new_r11))+(((-1.0)*new_r01*x188)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x189 = IKatan2WithCheck(IkReal(((-1.0)*new_r10)),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x189.valid){
continue;
}
CheckValue<IkReal> x190=IKPowWithIntegerCheck(IKsign(gconst13),-1);
if(!x190.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x189.value)+(((1.5707963267949)*(x190.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x191=IKsin(j6);
IkReal x192=IKcos(j6);
if((((1.0)+(((-1.0)*(gconst13*gconst13))))) < -0.00001)
continue;
IkReal x193=IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13)))));
IkReal x194=((1.0)*x193);
evalcond[0]=x191;
evalcond[1]=((-1.0)*x192);
evalcond[2]=(new_r10+((gconst13*x191)));
evalcond[3]=(new_r11+((gconst13*x192)));
evalcond[4]=((((-1.0)*x191*x194))+new_r00);
evalcond[5]=((((-1.0)*x192*x194))+new_r01);
evalcond[6]=(x191+((gconst13*new_r10))+(((-1.0)*new_r00*x194)));
evalcond[7]=(x192+(((-1.0)*new_r01*x194))+((gconst13*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x195=new_r22*new_r22;
CheckValue<IkReal> x196=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x195))),-1);
if(!x196.valid){
continue;
}
if((((-1.0)*x195*(x196.value))) < -0.00001)
continue;
IkReal gconst13=((-1.0)*(IKsqrt(((-1.0)*x195*(x196.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj4+(((-1.0)*gconst13)))))+(IKabs(((1.0)+(IKsign(sj4)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
IkReal x197=new_r22*new_r22;
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst13*gconst13))))) < -0.00001)
continue;
sj4=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13)))))));
cj4=gconst13;
if( (gconst13) < -1-IKFAST_SINCOS_THRESH || (gconst13) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=((-1.0)*(IKacos(gconst13)));
CheckValue<IkReal> x198=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x197))),-1);
if(!x198.valid){
continue;
}
if((((-1.0)*x197*(x198.value))) < -0.00001)
continue;
IkReal gconst13=((-1.0)*(IKsqrt(((-1.0)*x197*(x198.value)))));
j6eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x199=IKPowWithIntegerCheck(gconst13,-1);
if(!x199.valid){
continue;
}
if((((1.0)+(((-1.0)*(gconst13*gconst13))))) < -0.00001)
continue;
if( IKabs(((-1.0)*new_r10*(x199.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*gconst13*new_r11))+(((-1.0)*new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10*(x199.value)))+IKsqr(((((-1.0)*gconst13*new_r11))+(((-1.0)*new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13))))))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10*(x199.value)), ((((-1.0)*gconst13*new_r11))+(((-1.0)*new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13))))))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x200=IKsin(j6);
IkReal x201=IKcos(j6);
if((((1.0)+(((-1.0)*(gconst13*gconst13))))) < -0.00001)
continue;
IkReal x202=IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13)))));
evalcond[0]=x200;
evalcond[1]=((-1.0)*x201);
evalcond[2]=(((gconst13*x200))+new_r10);
evalcond[3]=(((gconst13*x201))+new_r11);
evalcond[4]=(((x200*x202))+new_r00);
evalcond[5]=(((x201*x202))+new_r01);
evalcond[6]=(((new_r00*x202))+x200+((gconst13*new_r10)));
evalcond[7]=(((new_r01*x202))+x201+((gconst13*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x203 = IKatan2WithCheck(IkReal(((-1.0)*new_r10)),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x203.valid){
continue;
}
CheckValue<IkReal> x204=IKPowWithIntegerCheck(IKsign(gconst13),-1);
if(!x204.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x203.value)+(((1.5707963267949)*(x204.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x205=IKsin(j6);
IkReal x206=IKcos(j6);
if((((1.0)+(((-1.0)*(gconst13*gconst13))))) < -0.00001)
continue;
IkReal x207=IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13)))));
evalcond[0]=x205;
evalcond[1]=((-1.0)*x206);
evalcond[2]=(((gconst13*x205))+new_r10);
evalcond[3]=(((gconst13*x206))+new_r11);
evalcond[4]=(((x205*x207))+new_r00);
evalcond[5]=(new_r01+((x206*x207)));
evalcond[6]=(((new_r00*x207))+x205+((gconst13*new_r10)));
evalcond[7]=(((new_r01*x207))+x206+((gconst13*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x208=(new_r01*new_r22);
IkReal x209=(cj4*new_r11);
CheckValue<IkReal> x210=IKPowWithIntegerCheck(cj4,-1);
if(!x210.valid){
continue;
}
if( IKabs(((x210.value)*((((new_r22*sj4*x209))+((x208*(cj4*cj4)))+(((-1.0)*new_r10))+(((-1.0)*x208)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj4))+(((-1.0)*x209)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x210.value)*((((new_r22*sj4*x209))+((x208*(cj4*cj4)))+(((-1.0)*new_r10))+(((-1.0)*x208))))))+IKsqr((((new_r01*sj4))+(((-1.0)*x209))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((x210.value)*((((new_r22*sj4*x209))+((x208*(cj4*cj4)))+(((-1.0)*new_r10))+(((-1.0)*x208))))), (((new_r01*sj4))+(((-1.0)*x209))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[10];
IkReal x211=IKcos(j6);
IkReal x212=IKsin(j6);
IkReal x213=((1.0)*new_r22);
IkReal x214=(new_r10*sj4);
IkReal x215=((1.0)*sj4);
IkReal x216=(new_r11*sj4);
IkReal x217=(cj4*new_r01);
IkReal x218=(cj4*new_r00);
IkReal x219=(new_r22*x211);
IkReal x220=(cj4*x212);
evalcond[0]=(((cj4*new_r10))+x212+(((-1.0)*new_r00*x215)));
evalcond[1]=(((cj4*new_r11))+x211+(((-1.0)*new_r01*x215)));
evalcond[2]=(x214+x218+x219);
evalcond[3]=(x220+new_r10+((sj4*x219)));
evalcond[4]=(x216+x217+(((-1.0)*x212*x213)));
evalcond[5]=(((cj4*x219))+new_r00+(((-1.0)*x212*x215)));
evalcond[6]=(((cj4*x211))+(((-1.0)*sj4*x212*x213))+new_r11);
evalcond[7]=(x212+(((-1.0)*x213*x217))+(((-1.0)*x213*x216)));
evalcond[8]=((((-1.0)*x213*x220))+(((-1.0)*x211*x215))+new_r01);
evalcond[9]=((((-1.0)*x211))+(((-1.0)*x213*x218))+(((-1.0)*x213*x214)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x221=((1.0)*new_r10);
CheckValue<IkReal> x222=IKPowWithIntegerCheck(new_r22,-1);
if(!x222.valid){
continue;
}
if( IKabs(((((-1.0)*cj4*x221))+((new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x222.value)*(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x221)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x221))+((new_r00*sj4))))+IKsqr(((x222.value)*(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x221))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*cj4*x221))+((new_r00*sj4))), ((x222.value)*(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x221))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[10];
IkReal x223=IKcos(j6);
IkReal x224=IKsin(j6);
IkReal x225=((1.0)*new_r22);
IkReal x226=(new_r10*sj4);
IkReal x227=((1.0)*sj4);
IkReal x228=(new_r11*sj4);
IkReal x229=(cj4*new_r01);
IkReal x230=(cj4*new_r00);
IkReal x231=(new_r22*x223);
IkReal x232=(cj4*x224);
evalcond[0]=(((cj4*new_r10))+x224+(((-1.0)*new_r00*x227)));
evalcond[1]=((((-1.0)*new_r01*x227))+((cj4*new_r11))+x223);
evalcond[2]=(x226+x230+x231);
evalcond[3]=(x232+((sj4*x231))+new_r10);
evalcond[4]=((((-1.0)*x224*x225))+x229+x228);
evalcond[5]=((((-1.0)*x224*x227))+((cj4*x231))+new_r00);
evalcond[6]=((((-1.0)*sj4*x224*x225))+((cj4*x223))+new_r11);
evalcond[7]=((((-1.0)*x225*x229))+(((-1.0)*x225*x228))+x224);
evalcond[8]=((((-1.0)*x225*x232))+(((-1.0)*x223*x227))+new_r01);
evalcond[9]=((((-1.0)*x225*x230))+(((-1.0)*x225*x226))+(((-1.0)*x223)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x233=cj4*cj4;
IkReal x234=new_r22*new_r22;
IkReal x235=((1.0)*cj4);
IkReal x236=(new_r22*sj4);
CheckValue<IkReal> x237 = IKatan2WithCheck(IkReal((((new_r11*x236))+(((-1.0)*new_r10*x235)))),IkReal(((((-1.0)*new_r10*x236))+(((-1.0)*new_r11*x235)))),IKFAST_ATAN2_MAGTHRESH);
if(!x237.valid){
continue;
}
CheckValue<IkReal> x238=IKPowWithIntegerCheck(IKsign(((((-1.0)*x233*x234))+x233+x234)),-1);
if(!x238.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x237.value)+(((1.5707963267949)*(x238.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[10];
IkReal x239=IKcos(j6);
IkReal x240=IKsin(j6);
IkReal x241=((1.0)*new_r22);
IkReal x242=(new_r10*sj4);
IkReal x243=((1.0)*sj4);
IkReal x244=(new_r11*sj4);
IkReal x245=(cj4*new_r01);
IkReal x246=(cj4*new_r00);
IkReal x247=(new_r22*x239);
IkReal x248=(cj4*x240);
evalcond[0]=(((cj4*new_r10))+(((-1.0)*new_r00*x243))+x240);
evalcond[1]=((((-1.0)*new_r01*x243))+((cj4*new_r11))+x239);
evalcond[2]=(x242+x247+x246);
evalcond[3]=(x248+new_r10+((sj4*x247)));
evalcond[4]=(x245+x244+(((-1.0)*x240*x241)));
evalcond[5]=(((cj4*x247))+(((-1.0)*x240*x243))+new_r00);
evalcond[6]=(((cj4*x239))+(((-1.0)*sj4*x240*x241))+new_r11);
evalcond[7]=((((-1.0)*x241*x244))+(((-1.0)*x241*x245))+x240);
evalcond[8]=((((-1.0)*x241*x248))+new_r01+(((-1.0)*x239*x243)));
evalcond[9]=((((-1.0)*x241*x242))+(((-1.0)*x241*x246))+(((-1.0)*x239)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x250=IKPowWithIntegerCheck(sj5,-1);
if(!x250.valid){
continue;
}
IkReal x249=x250.value;
CheckValue<IkReal> x251=IKPowWithIntegerCheck(new_r12,-1);
if(!x251.valid){
continue;
}
if( IKabs((x249*(x251.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x249)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x249*(x251.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5)))))))+IKsqr((new_r02*x249))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x249*(x251.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5)))))), (new_r02*x249));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x252=IKcos(j4);
IkReal x253=IKsin(j4);
IkReal x254=((1.0)*cj5);
IkReal x255=(new_r02*x252);
IkReal x256=(sj5*x252);
IkReal x257=(sj5*x253);
IkReal x258=(new_r12*x253);
evalcond[0]=(new_r02+(((-1.0)*x256)));
evalcond[1]=(new_r12+(((-1.0)*x257)));
evalcond[2]=(((new_r12*x252))+(((-1.0)*new_r02*x253)));
evalcond[3]=((((-1.0)*sj5))+x258+x255);
evalcond[4]=(((new_r00*x256))+((cj5*new_r20))+((new_r10*x257)));
evalcond[5]=(((new_r01*x256))+((cj5*new_r21))+((new_r11*x257)));
evalcond[6]=((-1.0)+((cj5*new_r22))+((new_r12*x257))+((sj5*x255)));
evalcond[7]=(((new_r22*sj5))+(((-1.0)*x254*x258))+(((-1.0)*x254*x255)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[3];
j6eval[0]=sj5;
j6eval[1]=IKsign(sj5);
j6eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
j6eval[0]=sj5;
j6eval[1]=cj4;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
j6eval[0]=sj5;
j6eval[1]=cj5;
j6eval[2]=sj4;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x259=((1.0)*new_r10);
if( IKabs(((((-1.0)*cj4*x259))+((new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x259)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x259))+((new_r00*sj4))))+IKsqr(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x259))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*cj4*x259))+((new_r00*sj4))), ((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x259))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x260=IKcos(j6);
IkReal x261=IKsin(j6);
IkReal x262=((1.0)*sj4);
IkReal x263=(cj4*x260);
IkReal x264=(cj4*x261);
IkReal x265=(x261*x262);
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x260);
evalcond[1]=((((-1.0)*new_r00*x262))+((cj4*new_r10))+x261);
evalcond[2]=((((-1.0)*new_r01*x262))+((cj4*new_r11))+x260);
evalcond[3]=(x264+new_r10+((sj4*x260)));
evalcond[4]=((((-1.0)*x261))+((cj4*new_r01))+((new_r11*sj4)));
evalcond[5]=(x263+new_r00+(((-1.0)*x265)));
evalcond[6]=(x263+new_r11+(((-1.0)*x265)));
evalcond[7]=((((-1.0)*x264))+new_r01+(((-1.0)*x260*x262)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x266=((1.0)*new_r11);
if( IKabs(((((-1.0)*cj4*new_r10))+(((-1.0)*sj4*x266)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj4*x266))+((new_r10*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*new_r10))+(((-1.0)*sj4*x266))))+IKsqr(((((-1.0)*cj4*x266))+((new_r10*sj4))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*cj4*new_r10))+(((-1.0)*sj4*x266))), ((((-1.0)*cj4*x266))+((new_r10*sj4))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x267=IKsin(j6);
IkReal x268=IKcos(j6);
IkReal x269=((1.0)*sj4);
IkReal x270=(cj4*x267);
IkReal x271=((1.0)*x268);
IkReal x272=(x268*x269);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x267);
evalcond[1]=((((-1.0)*new_r00*x269))+((cj4*new_r10))+x267);
evalcond[2]=((((-1.0)*new_r01*x269))+((cj4*new_r11))+x268);
evalcond[3]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x271)));
evalcond[4]=(((cj4*x268))+new_r11+((sj4*x267)));
evalcond[5]=(x270+(((-1.0)*x272))+new_r10);
evalcond[6]=(x270+(((-1.0)*x272))+new_r01);
evalcond[7]=((((-1.0)*cj4*x271))+(((-1.0)*x267*x269))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x273=IKsin(j6);
IkReal x274=IKcos(j6);
IkReal x275=((1.0)*sj4);
IkReal x276=((1.0)*x274);
evalcond[0]=(x273+new_r21);
evalcond[1]=((((-1.0)*x276))+new_r20);
evalcond[2]=(((cj4*x273))+new_r10);
evalcond[3]=(((cj4*x274))+new_r11);
evalcond[4]=((((-1.0)*x273*x275))+new_r00);
evalcond[5]=((((-1.0)*new_r12*x276))+new_r01);
evalcond[6]=(((cj4*new_r10))+(((-1.0)*new_r00*x275))+x273);
evalcond[7]=((((-1.0)*new_r01*x275))+((cj4*new_r11))+x274);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x277=IKsin(j6);
IkReal x278=IKcos(j6);
IkReal x279=((1.0)*sj4);
evalcond[0]=(x278+new_r20);
evalcond[1]=((((-1.0)*x277))+new_r21);
evalcond[2]=(((cj4*x277))+new_r10);
evalcond[3]=(((cj4*x278))+new_r11);
evalcond[4]=(new_r01+((new_r12*x278)));
evalcond[5]=((((-1.0)*x277*x279))+new_r00);
evalcond[6]=(((cj4*new_r10))+(((-1.0)*new_r00*x279))+x277);
evalcond[7]=((((-1.0)*new_r01*x279))+((cj4*new_r11))+x278);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x280=IKsin(j6);
IkReal x281=IKcos(j6);
IkReal x282=((1.0)*cj5);
IkReal x283=((1.0)*x281);
evalcond[0]=(x280+new_r10);
evalcond[1]=(x281+new_r11);
evalcond[2]=(((new_r02*x280))+new_r21);
evalcond[3]=(new_r00+((cj5*x281)));
evalcond[4]=((((-1.0)*new_r02*x283))+new_r20);
evalcond[5]=((((-1.0)*x280*x282))+new_r01);
evalcond[6]=(x280+(((-1.0)*new_r01*x282))+((new_r21*sj5)));
evalcond[7]=(((new_r20*sj5))+(((-1.0)*new_r00*x282))+(((-1.0)*x283)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r10, new_r11);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x284=IKcos(j6);
IkReal x285=IKsin(j6);
IkReal x286=((1.0)*x285);
evalcond[0]=(((new_r02*x284))+new_r20);
evalcond[1]=(x285+(((-1.0)*new_r10)));
evalcond[2]=(x284+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*new_r02*x286))+new_r21);
evalcond[4]=((((-1.0)*new_r00))+((cj5*x284)));
evalcond[5]=((((-1.0)*cj5*x286))+(((-1.0)*new_r01)));
evalcond[6]=(((cj5*new_r01))+x285+((new_r21*sj5)));
evalcond[7]=(((new_r20*sj5))+((cj5*new_r00))+(((-1.0)*x284)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r00, new_r01);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x287=IKsin(j6);
IkReal x288=IKcos(j6);
IkReal x289=((1.0)*cj5);
IkReal x290=((1.0)*x288);
evalcond[0]=(((new_r12*x287))+new_r21);
evalcond[1]=(x287+(((-1.0)*new_r00)));
evalcond[2]=(x288+(((-1.0)*new_r01)));
evalcond[3]=(new_r10+((cj5*x288)));
evalcond[4]=((((-1.0)*new_r12*x290))+new_r20);
evalcond[5]=((((-1.0)*x287*x289))+new_r11);
evalcond[6]=(x287+(((-1.0)*new_r11*x289))+((new_r21*sj5)));
evalcond[7]=(((new_r20*sj5))+(((-1.0)*x290))+(((-1.0)*new_r10*x289)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x291=IKcos(j6);
IkReal x292=IKsin(j6);
IkReal x293=((1.0)*x292);
evalcond[0]=(x292+new_r00);
evalcond[1]=(x291+new_r01);
evalcond[2]=(((new_r12*x291))+new_r20);
evalcond[3]=((((-1.0)*new_r12*x293))+new_r21);
evalcond[4]=(((cj5*x291))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*cj5*x293))+(((-1.0)*new_r11)));
evalcond[6]=(((cj5*new_r11))+x292+((new_r21*sj5)));
evalcond[7]=((((-1.0)*x291))+((new_r20*sj5))+((cj5*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j6eval[0]=1.0;
if( IKabs(j6eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j6]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=-1.0;
op[1]=0;
op[2]=1.0;
polyroots2(op,zeror,numroots);
IkReal j6array[2], cj6array[2], sj6array[2], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[2]={true,true};
_nj6 = 2;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x295=IKPowWithIntegerCheck(sj5,-1);
if(!x295.valid){
continue;
}
IkReal x294=x295.value;
CheckValue<IkReal> x296=IKPowWithIntegerCheck(cj5,-1);
if(!x296.valid){
continue;
}
CheckValue<IkReal> x297=IKPowWithIntegerCheck(sj4,-1);
if(!x297.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x294)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x294*(x296.value)*(x297.value)*((((cj4*new_r21))+(((-1.0)*new_r10*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x294))+IKsqr((x294*(x296.value)*(x297.value)*((((cj4*new_r21))+(((-1.0)*new_r10*sj5))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21*x294), (x294*(x296.value)*(x297.value)*((((cj4*new_r21))+(((-1.0)*new_r10*sj5))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x298=IKsin(j6);
IkReal x299=IKcos(j6);
IkReal x300=((1.0)*sj4);
IkReal x301=(cj4*cj5);
IkReal x302=(cj5*x298);
IkReal x303=((1.0)*x299);
IkReal x304=(cj5*x299);
evalcond[0]=(((sj5*x298))+new_r21);
evalcond[1]=(new_r20+(((-1.0)*sj5*x303)));
evalcond[2]=(((cj4*new_r10))+x298+(((-1.0)*new_r00*x300)));
evalcond[3]=(((cj4*new_r11))+x299+(((-1.0)*new_r01*x300)));
evalcond[4]=(((cj4*new_r00))+((new_r10*sj4))+x304);
evalcond[5]=(((cj4*x298))+((sj4*x304))+new_r10);
evalcond[6]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x302)));
evalcond[7]=((((-1.0)*x298*x300))+((x299*x301))+new_r00);
evalcond[8]=(((cj4*x299))+new_r11+(((-1.0)*x300*x302)));
evalcond[9]=((((-1.0)*x298*x301))+(((-1.0)*x299*x300))+new_r01);
evalcond[10]=((((-1.0)*new_r01*x301))+(((-1.0)*cj5*new_r11*x300))+x298+((new_r21*sj5)));
evalcond[11]=((((-1.0)*new_r00*x301))+((new_r20*sj5))+(((-1.0)*cj5*new_r10*x300))+(((-1.0)*x303)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x306=IKPowWithIntegerCheck(sj5,-1);
if(!x306.valid){
continue;
}
IkReal x305=x306.value;
CheckValue<IkReal> x307=IKPowWithIntegerCheck(cj4,-1);
if(!x307.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x305)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x305*(x307.value)*(((((-1.0)*cj5*new_r21*sj4))+(((-1.0)*new_r11*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x305))+IKsqr((x305*(x307.value)*(((((-1.0)*cj5*new_r21*sj4))+(((-1.0)*new_r11*sj5))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21*x305), (x305*(x307.value)*(((((-1.0)*cj5*new_r21*sj4))+(((-1.0)*new_r11*sj5))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x308=IKsin(j6);
IkReal x309=IKcos(j6);
IkReal x310=((1.0)*sj4);
IkReal x311=(cj4*cj5);
IkReal x312=(cj5*x308);
IkReal x313=((1.0)*x309);
IkReal x314=(cj5*x309);
evalcond[0]=(((sj5*x308))+new_r21);
evalcond[1]=((((-1.0)*sj5*x313))+new_r20);
evalcond[2]=((((-1.0)*new_r00*x310))+((cj4*new_r10))+x308);
evalcond[3]=(((cj4*new_r11))+x309+(((-1.0)*new_r01*x310)));
evalcond[4]=(((cj4*new_r00))+((new_r10*sj4))+x314);
evalcond[5]=(((sj4*x314))+new_r10+((cj4*x308)));
evalcond[6]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x312)));
evalcond[7]=((((-1.0)*x308*x310))+((x309*x311))+new_r00);
evalcond[8]=((((-1.0)*x310*x312))+new_r11+((cj4*x309)));
evalcond[9]=((((-1.0)*x308*x311))+new_r01+(((-1.0)*x309*x310)));
evalcond[10]=((((-1.0)*new_r01*x311))+(((-1.0)*cj5*new_r11*x310))+x308+((new_r21*sj5)));
evalcond[11]=(((new_r20*sj5))+(((-1.0)*new_r00*x311))+(((-1.0)*cj5*new_r10*x310))+(((-1.0)*x313)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x315 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),IkReal(new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x315.valid){
continue;
}
CheckValue<IkReal> x316=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x316.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x315.value)+(((1.5707963267949)*(x316.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x317=IKsin(j6);
IkReal x318=IKcos(j6);
IkReal x319=((1.0)*sj4);
IkReal x320=(cj4*cj5);
IkReal x321=(cj5*x317);
IkReal x322=((1.0)*x318);
IkReal x323=(cj5*x318);
evalcond[0]=(((sj5*x317))+new_r21);
evalcond[1]=(new_r20+(((-1.0)*sj5*x322)));
evalcond[2]=((((-1.0)*new_r00*x319))+((cj4*new_r10))+x317);
evalcond[3]=(((cj4*new_r11))+x318+(((-1.0)*new_r01*x319)));
evalcond[4]=(((cj4*new_r00))+((new_r10*sj4))+x323);
evalcond[5]=(((sj4*x323))+((cj4*x317))+new_r10);
evalcond[6]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x321)));
evalcond[7]=(((x318*x320))+new_r00+(((-1.0)*x317*x319)));
evalcond[8]=(((cj4*x318))+(((-1.0)*x319*x321))+new_r11);
evalcond[9]=((((-1.0)*x317*x320))+(((-1.0)*x318*x319))+new_r01);
evalcond[10]=((((-1.0)*cj5*new_r11*x319))+x317+((new_r21*sj5))+(((-1.0)*new_r01*x320)));
evalcond[11]=(((new_r20*sj5))+(((-1.0)*x322))+(((-1.0)*new_r00*x320))+(((-1.0)*cj5*new_r10*x319)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x324 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),IkReal(new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x324.valid){
continue;
}
CheckValue<IkReal> x325=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x325.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x324.value)+(((1.5707963267949)*(x325.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
evalcond[0]=(((sj5*(IKsin(j6))))+new_r21);
evalcond[1]=((((-1.0)*sj5*(IKcos(j6))))+new_r20);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[3];
j4eval[0]=sj5;
j4eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j4eval[2]=IKsign(sj5);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=new_r00;
j4eval[1]=sj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
sj5=0;
cj5=1.0;
j5=0;
IkReal x326=((1.0)*new_r10);
IkReal x327=((new_r10*new_r10)+(new_r00*new_r00));
j4eval[0]=x327;
j4eval[1]=((IKabs(((((-1.0)*cj6*new_r00))+(((-1.0)*sj6*x326)))))+(IKabs(((((-1.0)*cj6*x326))+((new_r00*sj6))))));
j4eval[2]=IKsign(x327);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
sj5=0;
cj5=1.0;
j5=0;
IkReal x328=((1.0)*cj6);
IkReal x329=(((new_r10*new_r11))+((new_r00*new_r01)));
j4eval[0]=x329;
j4eval[1]=((IKabs((((cj6*new_r00))+(((-1.0)*new_r11*x328)))))+(IKabs(((((-1.0)*new_r01*x328))+(((-1.0)*new_r10*x328))))));
j4eval[2]=IKsign(x329);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
sj5=0;
cj5=1.0;
j5=0;
IkReal x330=((1.0)*new_r10);
IkReal x331=((((-1.0)*sj6*x330))+((cj6*new_r00)));
j4eval[0]=x331;
j4eval[1]=IKsign(x331);
j4eval[2]=((IKabs(((((-1.0)*(cj6*cj6)))+(new_r10*new_r10))))+(IKabs((((cj6*sj6))+(((-1.0)*new_r00*x330))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x334 = ((new_r10*new_r10)+(new_r00*new_r00));
if(IKabs(x334)==0){
continue;
}
IkReal x332=pow(x334,-0.5);
IkReal x333=((-1.0)*x332);
CheckValue<IkReal> x335 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x335.valid){
continue;
}
IkReal gconst0=((-1.0)*(x335.value));
IkReal gconst1=(new_r00*x333);
IkReal gconst2=(new_r10*x333);
CheckValue<IkReal> x336 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x336.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x336.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[2];
CheckValue<IkReal> x340 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x340.valid){
continue;
}
IkReal x337=((-1.0)*(x340.value));
IkReal x338=x332;
IkReal x339=((-1.0)*x338);
sj5=0;
cj5=1.0;
j5=0;
sj6=gconst1;
cj6=gconst2;
j6=x337;
IkReal gconst0=x337;
IkReal gconst1=(new_r00*x339);
IkReal gconst2=(new_r10*x339);
IkReal x341=((new_r10*new_r10)+(new_r00*new_r00));
j4eval[0]=x341;
j4eval[1]=IKsign(x341);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
CheckValue<IkReal> x345 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x345.valid){
continue;
}
IkReal x342=((-1.0)*(x345.value));
IkReal x343=x332;
IkReal x344=((-1.0)*x343);
sj5=0;
cj5=1.0;
j5=0;
sj6=gconst1;
cj6=gconst2;
j6=x342;
IkReal gconst0=x342;
IkReal gconst1=(new_r00*x344);
IkReal gconst2=(new_r10*x344);
IkReal x346=new_r10*new_r10;
IkReal x347=(((new_r10*new_r11))+((new_r00*new_r01)));
IkReal x348=x332;
IkReal x349=(new_r10*x348);
j4eval[0]=x347;
j4eval[1]=IKsign(x347);
j4eval[2]=((IKabs((((new_r01*x349))+((x346*x348)))))+(IKabs(((((-1.0)*new_r00*x349))+((new_r11*x349))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
CheckValue<IkReal> x353 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x353.valid){
continue;
}
IkReal x350=((-1.0)*(x353.value));
IkReal x351=x332;
IkReal x352=((-1.0)*x351);
sj5=0;
cj5=1.0;
j5=0;
sj6=gconst1;
cj6=gconst2;
j6=x350;
IkReal gconst0=x350;
IkReal gconst1=(new_r00*x352);
IkReal gconst2=(new_r10*x352);
IkReal x354=new_r10*new_r10;
IkReal x355=new_r00*new_r00;
CheckValue<IkReal> x362=IKPowWithIntegerCheck((x355+x354),-1);
if(!x362.valid){
continue;
}
IkReal x356=x362.value;
IkReal x357=(x354*x356);
CheckValue<IkReal> x363=IKPowWithIntegerCheck(((((-1.0)*x355))+(((-1.0)*x354))),-1);
if(!x363.valid){
continue;
}
IkReal x358=x363.value;
IkReal x359=((1.0)*x358);
IkReal x360=(new_r00*x359);
IkReal x361=(new_r10*x359);
j4eval[0]=((IKabs(((((-1.0)*new_r10*x360*(new_r00*new_r00)))+(((-1.0)*x360*(new_r10*new_r10*new_r10)))+(((-1.0)*new_r10*x360)))))+(IKabs((((x355*x357))+(((-1.0)*x357))+((x356*(x355*x355)))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x364 = IKatan2WithCheck(IkReal(((((-1.0)*(gconst2*gconst2)))+(new_r00*new_r00))),IkReal(((((-1.0)*gconst1*gconst2))+(((-1.0)*new_r00*new_r10)))),IKFAST_ATAN2_MAGTHRESH);
if(!x364.valid){
continue;
}
CheckValue<IkReal> x365=IKPowWithIntegerCheck(IKsign((((gconst2*new_r10))+((gconst1*new_r00)))),-1);
if(!x365.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x364.value)+(((1.5707963267949)*(x365.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x366=IKcos(j4);
IkReal x367=IKsin(j4);
IkReal x368=(gconst2*x366);
IkReal x369=((1.0)*x367);
IkReal x370=(gconst1*x366);
IkReal x371=(gconst1*x369);
evalcond[0]=(gconst2+((new_r00*x366))+((new_r10*x367)));
evalcond[1]=(((gconst2*x367))+x370+new_r10);
evalcond[2]=((((-1.0)*new_r00*x369))+gconst1+((new_r10*x366)));
evalcond[3]=(gconst2+(((-1.0)*new_r01*x369))+((new_r11*x366)));
evalcond[4]=((((-1.0)*x371))+x368+new_r00);
evalcond[5]=((((-1.0)*x371))+x368+new_r11);
evalcond[6]=((((-1.0)*gconst1))+((new_r01*x366))+((new_r11*x367)));
evalcond[7]=((((-1.0)*x370))+new_r01+(((-1.0)*gconst2*x369)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x372=((1.0)*gconst2);
CheckValue<IkReal> x373 = IKatan2WithCheck(IkReal((((gconst2*new_r00))+(((-1.0)*new_r11*x372)))),IkReal(((((-1.0)*new_r10*x372))+(((-1.0)*new_r01*x372)))),IKFAST_ATAN2_MAGTHRESH);
if(!x373.valid){
continue;
}
CheckValue<IkReal> x374=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x374.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x373.value)+(((1.5707963267949)*(x374.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x375=IKcos(j4);
IkReal x376=IKsin(j4);
IkReal x377=(gconst2*x375);
IkReal x378=((1.0)*x376);
IkReal x379=(gconst1*x375);
IkReal x380=(gconst1*x378);
evalcond[0]=(gconst2+((new_r00*x375))+((new_r10*x376)));
evalcond[1]=(((gconst2*x376))+x379+new_r10);
evalcond[2]=((((-1.0)*new_r00*x378))+gconst1+((new_r10*x375)));
evalcond[3]=(gconst2+(((-1.0)*new_r01*x378))+((new_r11*x375)));
evalcond[4]=(x377+(((-1.0)*x380))+new_r00);
evalcond[5]=(x377+(((-1.0)*x380))+new_r11);
evalcond[6]=((((-1.0)*gconst1))+((new_r01*x375))+((new_r11*x376)));
evalcond[7]=((((-1.0)*x379))+new_r01+(((-1.0)*gconst2*x378)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x381=((1.0)*new_r10);
CheckValue<IkReal> x382=IKPowWithIntegerCheck(IKsign(((new_r10*new_r10)+(new_r00*new_r00))),-1);
if(!x382.valid){
continue;
}
CheckValue<IkReal> x383 = IKatan2WithCheck(IkReal((((gconst1*new_r00))+(((-1.0)*gconst2*x381)))),IkReal(((((-1.0)*gconst2*new_r00))+(((-1.0)*gconst1*x381)))),IKFAST_ATAN2_MAGTHRESH);
if(!x383.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x382.value)))+(x383.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x384=IKcos(j4);
IkReal x385=IKsin(j4);
IkReal x386=(gconst2*x384);
IkReal x387=((1.0)*x385);
IkReal x388=(gconst1*x384);
IkReal x389=(gconst1*x387);
evalcond[0]=(((new_r00*x384))+gconst2+((new_r10*x385)));
evalcond[1]=(x388+((gconst2*x385))+new_r10);
evalcond[2]=((((-1.0)*new_r00*x387))+gconst1+((new_r10*x384)));
evalcond[3]=(gconst2+(((-1.0)*new_r01*x387))+((new_r11*x384)));
evalcond[4]=(x386+(((-1.0)*x389))+new_r00);
evalcond[5]=(x386+(((-1.0)*x389))+new_r11);
evalcond[6]=(((new_r01*x384))+(((-1.0)*gconst1))+((new_r11*x385)));
evalcond[7]=((((-1.0)*x388))+(((-1.0)*gconst2*x387))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x392 = ((new_r10*new_r10)+(new_r00*new_r00));
if(IKabs(x392)==0){
continue;
}
IkReal x390=pow(x392,-0.5);
IkReal x391=((1.0)*x390);
CheckValue<IkReal> x393 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x393.valid){
continue;
}
IkReal gconst3=((3.14159265358979)+(((-1.0)*(x393.value))));
IkReal gconst4=(new_r00*x391);
IkReal gconst5=(new_r10*x391);
CheckValue<IkReal> x394 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x394.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x394.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[2];
CheckValue<IkReal> x398 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x398.valid){
continue;
}
IkReal x395=((1.0)*(x398.value));
IkReal x396=x390;
IkReal x397=((1.0)*x396);
sj5=0;
cj5=1.0;
j5=0;
sj6=gconst4;
cj6=gconst5;
j6=((3.14159265)+(((-1.0)*x395)));
IkReal gconst3=((3.14159265358979)+(((-1.0)*x395)));
IkReal gconst4=(new_r00*x397);
IkReal gconst5=(new_r10*x397);
IkReal x399=((new_r10*new_r10)+(new_r00*new_r00));
j4eval[0]=x399;
j4eval[1]=IKsign(x399);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
CheckValue<IkReal> x403 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x403.valid){
continue;
}
IkReal x400=((1.0)*(x403.value));
IkReal x401=x390;
IkReal x402=((1.0)*x401);
sj5=0;
cj5=1.0;
j5=0;
sj6=gconst4;
cj6=gconst5;
j6=((3.14159265)+(((-1.0)*x400)));
IkReal gconst3=((3.14159265358979)+(((-1.0)*x400)));
IkReal gconst4=(new_r00*x402);
IkReal gconst5=(new_r10*x402);
IkReal x404=new_r10*new_r10;
IkReal x405=(new_r10*new_r11);
IkReal x406=(((new_r00*new_r01))+x405);
IkReal x407=x390;
IkReal x408=((1.0)*x407);
j4eval[0]=x406;
j4eval[1]=((IKabs(((((-1.0)*new_r01*new_r10*x408))+(((-1.0)*x404*x408)))))+(IKabs((((new_r00*new_r10*x407))+(((-1.0)*x405*x408))))));
j4eval[2]=IKsign(x406);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
CheckValue<IkReal> x412 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x412.valid){
continue;
}
IkReal x409=((1.0)*(x412.value));
IkReal x410=x390;
IkReal x411=((1.0)*x410);
sj5=0;
cj5=1.0;
j5=0;
sj6=gconst4;
cj6=gconst5;
j6=((3.14159265)+(((-1.0)*x409)));
IkReal gconst3=((3.14159265358979)+(((-1.0)*x409)));
IkReal gconst4=(new_r00*x411);
IkReal gconst5=(new_r10*x411);
IkReal x413=new_r10*new_r10;
IkReal x414=new_r00*new_r00;
CheckValue<IkReal> x421=IKPowWithIntegerCheck((x413+x414),-1);
if(!x421.valid){
continue;
}
IkReal x415=x421.value;
IkReal x416=(x413*x415);
CheckValue<IkReal> x422=IKPowWithIntegerCheck(((((-1.0)*x414))+(((-1.0)*x413))),-1);
if(!x422.valid){
continue;
}
IkReal x417=x422.value;
IkReal x418=((1.0)*x417);
IkReal x419=(new_r00*x418);
IkReal x420=(new_r10*x418);
j4eval[0]=((IKabs((((x414*x416))+((x415*(x414*x414)))+(((-1.0)*x416)))))+(IKabs(((((-1.0)*x419*(new_r10*new_r10*new_r10)))+(((-1.0)*new_r10*x419))+(((-1.0)*new_r10*x419*(new_r00*new_r00)))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x423=IKPowWithIntegerCheck(IKsign((((gconst4*new_r00))+((gconst5*new_r10)))),-1);
if(!x423.valid){
continue;
}
CheckValue<IkReal> x424 = IKatan2WithCheck(IkReal(((((-1.0)*(gconst5*gconst5)))+(new_r00*new_r00))),IkReal(((((-1.0)*gconst4*gconst5))+(((-1.0)*new_r00*new_r10)))),IKFAST_ATAN2_MAGTHRESH);
if(!x424.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x423.value)))+(x424.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x425=IKsin(j4);
IkReal x426=IKcos(j4);
IkReal x427=((1.0)*gconst4);
IkReal x428=(gconst5*x426);
IkReal x429=(gconst5*x425);
IkReal x430=((1.0)*x425);
IkReal x431=(x425*x427);
evalcond[0]=(gconst5+((new_r10*x425))+((new_r00*x426)));
evalcond[1]=(((gconst4*x426))+x429+new_r10);
evalcond[2]=((((-1.0)*new_r00*x430))+gconst4+((new_r10*x426)));
evalcond[3]=((((-1.0)*new_r01*x430))+gconst5+((new_r11*x426)));
evalcond[4]=((((-1.0)*x431))+x428+new_r00);
evalcond[5]=((((-1.0)*x431))+x428+new_r11);
evalcond[6]=((((-1.0)*x427))+((new_r11*x425))+((new_r01*x426)));
evalcond[7]=((((-1.0)*x429))+(((-1.0)*x426*x427))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x432=((1.0)*gconst5);
CheckValue<IkReal> x433 = IKatan2WithCheck(IkReal((((gconst5*new_r00))+(((-1.0)*new_r11*x432)))),IkReal(((((-1.0)*new_r01*x432))+(((-1.0)*new_r10*x432)))),IKFAST_ATAN2_MAGTHRESH);
if(!x433.valid){
continue;
}
CheckValue<IkReal> x434=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x434.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x433.value)+(((1.5707963267949)*(x434.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x435=IKsin(j4);
IkReal x436=IKcos(j4);
IkReal x437=((1.0)*gconst4);
IkReal x438=(gconst5*x436);
IkReal x439=(gconst5*x435);
IkReal x440=((1.0)*x435);
IkReal x441=(x435*x437);
evalcond[0]=(((new_r00*x436))+gconst5+((new_r10*x435)));
evalcond[1]=(((gconst4*x436))+x439+new_r10);
evalcond[2]=((((-1.0)*new_r00*x440))+gconst4+((new_r10*x436)));
evalcond[3]=((((-1.0)*new_r01*x440))+gconst5+((new_r11*x436)));
evalcond[4]=((((-1.0)*x441))+x438+new_r00);
evalcond[5]=((((-1.0)*x441))+x438+new_r11);
evalcond[6]=(((new_r01*x436))+(((-1.0)*x437))+((new_r11*x435)));
evalcond[7]=((((-1.0)*x439))+(((-1.0)*x436*x437))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x442=((1.0)*new_r10);
CheckValue<IkReal> x443=IKPowWithIntegerCheck(IKsign(((new_r10*new_r10)+(new_r00*new_r00))),-1);
if(!x443.valid){
continue;
}
CheckValue<IkReal> x444 = IKatan2WithCheck(IkReal((((gconst4*new_r00))+(((-1.0)*gconst5*x442)))),IkReal(((((-1.0)*gconst4*x442))+(((-1.0)*gconst5*new_r00)))),IKFAST_ATAN2_MAGTHRESH);
if(!x444.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x443.value)))+(x444.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x445=IKsin(j4);
IkReal x446=IKcos(j4);
IkReal x447=((1.0)*gconst4);
IkReal x448=(gconst5*x446);
IkReal x449=(gconst5*x445);
IkReal x450=((1.0)*x445);
IkReal x451=(x445*x447);
evalcond[0]=(((new_r00*x446))+gconst5+((new_r10*x445)));
evalcond[1]=(((gconst4*x446))+x449+new_r10);
evalcond[2]=(gconst4+(((-1.0)*new_r00*x450))+((new_r10*x446)));
evalcond[3]=(gconst5+(((-1.0)*new_r01*x450))+((new_r11*x446)));
evalcond[4]=((((-1.0)*x451))+x448+new_r00);
evalcond[5]=((((-1.0)*x451))+x448+new_r11);
evalcond[6]=((((-1.0)*x447))+((new_r01*x446))+((new_r11*x445)));
evalcond[7]=((((-1.0)*x449))+new_r01+(((-1.0)*x446*x447)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r00, ((-1.0)*new_r10));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x452=IKcos(j4);
IkReal x453=IKsin(j4);
IkReal x454=((1.0)*x453);
evalcond[0]=(x452+new_r10);
evalcond[1]=((((-1.0)*x454))+new_r00);
evalcond[2]=((((-1.0)*x454))+new_r11);
evalcond[3]=((((-1.0)*x452))+new_r01);
evalcond[4]=(((new_r10*x453))+((new_r00*x452)));
evalcond[5]=(((new_r11*x452))+(((-1.0)*new_r01*x454)));
evalcond[6]=((-1.0)+((new_r11*x453))+((new_r01*x452)));
evalcond[7]=((1.0)+((new_r10*x452))+(((-1.0)*new_r00*x454)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x455=IKsin(j4);
IkReal x456=IKcos(j4);
IkReal x457=((1.0)*x455);
evalcond[0]=(x455+new_r00);
evalcond[1]=(x455+new_r11);
evalcond[2]=(x456+new_r01);
evalcond[3]=((((-1.0)*x456))+new_r10);
evalcond[4]=(((new_r10*x455))+((new_r00*x456)));
evalcond[5]=(((new_r11*x456))+(((-1.0)*new_r01*x457)));
evalcond[6]=((1.0)+((new_r11*x455))+((new_r01*x456)));
evalcond[7]=((-1.0)+((new_r10*x456))+(((-1.0)*new_r00*x457)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((new_r10*new_r10)+(new_r00*new_r00));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj5=0;
cj5=1.0;
j5=0;
new_r10=0;
new_r00=0;
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x459 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x459.valid){
continue;
}
IkReal x458=x459.value;
j4array[0]=((-1.0)*x458);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x458)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
evalcond[0]=(((new_r11*(IKcos(j4))))+(((-1.0)*new_r01*(IKsin(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj5=0;
cj5=1.0;
j5=0;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x461 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x461.valid){
continue;
}
IkReal x460=x461.value;
j4array[0]=((-1.0)*x460);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x460)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
evalcond[0]=(((new_r11*(IKcos(j4))))+(((-1.0)*new_r01*(IKsin(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x462=((1.0)*new_r10);
CheckValue<IkReal> x463 = IKatan2WithCheck(IkReal((((cj6*sj6))+(((-1.0)*new_r00*x462)))),IkReal(((((-1.0)*(cj6*cj6)))+(new_r10*new_r10))),IKFAST_ATAN2_MAGTHRESH);
if(!x463.valid){
continue;
}
CheckValue<IkReal> x464=IKPowWithIntegerCheck(IKsign((((cj6*new_r00))+(((-1.0)*sj6*x462)))),-1);
if(!x464.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x463.value)+(((1.5707963267949)*(x464.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x465=IKcos(j4);
IkReal x466=IKsin(j4);
IkReal x467=((1.0)*sj6);
IkReal x468=(cj6*x465);
IkReal x469=(cj6*x466);
IkReal x470=(sj6*x465);
IkReal x471=((1.0)*x466);
IkReal x472=(x466*x467);
evalcond[0]=(((new_r10*x466))+cj6+((new_r00*x465)));
evalcond[1]=(x469+x470+new_r10);
evalcond[2]=(sj6+((new_r10*x465))+(((-1.0)*new_r00*x471)));
evalcond[3]=(((new_r11*x465))+cj6+(((-1.0)*new_r01*x471)));
evalcond[4]=((((-1.0)*x472))+x468+new_r00);
evalcond[5]=((((-1.0)*x472))+x468+new_r11);
evalcond[6]=(((new_r11*x466))+((new_r01*x465))+(((-1.0)*x467)));
evalcond[7]=((((-1.0)*x465*x467))+(((-1.0)*x469))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x473=((1.0)*cj6);
CheckValue<IkReal> x474 = IKatan2WithCheck(IkReal(((((-1.0)*new_r11*x473))+((cj6*new_r00)))),IkReal(((((-1.0)*new_r10*x473))+(((-1.0)*new_r01*x473)))),IKFAST_ATAN2_MAGTHRESH);
if(!x474.valid){
continue;
}
CheckValue<IkReal> x475=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x475.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x474.value)+(((1.5707963267949)*(x475.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x476=IKcos(j4);
IkReal x477=IKsin(j4);
IkReal x478=((1.0)*sj6);
IkReal x479=(cj6*x476);
IkReal x480=(cj6*x477);
IkReal x481=(sj6*x476);
IkReal x482=((1.0)*x477);
IkReal x483=(x477*x478);
evalcond[0]=(cj6+((new_r10*x477))+((new_r00*x476)));
evalcond[1]=(x481+x480+new_r10);
evalcond[2]=(sj6+(((-1.0)*new_r00*x482))+((new_r10*x476)));
evalcond[3]=((((-1.0)*new_r01*x482))+cj6+((new_r11*x476)));
evalcond[4]=((((-1.0)*x483))+x479+new_r00);
evalcond[5]=((((-1.0)*x483))+x479+new_r11);
evalcond[6]=(((new_r01*x476))+((new_r11*x477))+(((-1.0)*x478)));
evalcond[7]=((((-1.0)*x476*x478))+(((-1.0)*x480))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x484=((1.0)*new_r10);
CheckValue<IkReal> x485=IKPowWithIntegerCheck(IKsign(((new_r10*new_r10)+(new_r00*new_r00))),-1);
if(!x485.valid){
continue;
}
CheckValue<IkReal> x486 = IKatan2WithCheck(IkReal(((((-1.0)*cj6*x484))+((new_r00*sj6)))),IkReal(((((-1.0)*cj6*new_r00))+(((-1.0)*sj6*x484)))),IKFAST_ATAN2_MAGTHRESH);
if(!x486.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x485.value)))+(x486.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x487=IKcos(j4);
IkReal x488=IKsin(j4);
IkReal x489=((1.0)*sj6);
IkReal x490=(cj6*x487);
IkReal x491=(cj6*x488);
IkReal x492=(sj6*x487);
IkReal x493=((1.0)*x488);
IkReal x494=(x488*x489);
evalcond[0]=(cj6+((new_r10*x488))+((new_r00*x487)));
evalcond[1]=(x492+x491+new_r10);
evalcond[2]=((((-1.0)*new_r00*x493))+sj6+((new_r10*x487)));
evalcond[3]=(cj6+(((-1.0)*new_r01*x493))+((new_r11*x487)));
evalcond[4]=((((-1.0)*x494))+x490+new_r00);
evalcond[5]=((((-1.0)*x494))+x490+new_r11);
evalcond[6]=((((-1.0)*x489))+((new_r11*x488))+((new_r01*x487)));
evalcond[7]=((((-1.0)*x487*x489))+(((-1.0)*x491))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x495=((1.0)*sj6);
IkReal x496=(((new_r10*new_r11))+((new_r00*new_r01)));
j4eval[0]=x496;
j4eval[1]=IKsign(x496);
j4eval[2]=((IKabs(((((-1.0)*new_r00*x495))+(((-1.0)*new_r11*x495)))))+(IKabs(((((-1.0)*new_r10*x495))+((new_r01*sj6))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x497=((1.0)*new_r11);
IkReal x498=((new_r01*new_r01)+(new_r11*new_r11));
j4eval[0]=x498;
j4eval[1]=((IKabs(((((-1.0)*sj6*x497))+((cj6*new_r01)))))+(IKabs(((((-1.0)*new_r01*sj6))+(((-1.0)*cj6*x497))))));
j4eval[2]=IKsign(x498);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x499=(((new_r11*sj6))+((cj6*new_r01)));
j4eval[0]=x499;
j4eval[1]=((IKabs(((((-1.0)*cj6*sj6))+(((-1.0)*new_r10*new_r11)))))+(IKabs(((-1.0)+((new_r01*new_r10))+(cj6*cj6)))));
j4eval[2]=IKsign(x499);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x501 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x501)==0){
continue;
}
IkReal x500=pow(x501,-0.5);
CheckValue<IkReal> x502 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x502.valid){
continue;
}
IkReal gconst6=((-1.0)*(x502.value));
IkReal gconst7=((-1.0)*new_r01*x500);
IkReal gconst8=(new_r11*x500);
CheckValue<IkReal> x503 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x503.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x503.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
CheckValue<IkReal> x506 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x506.valid){
continue;
}
IkReal x504=((-1.0)*(x506.value));
IkReal x505=x500;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst7;
cj6=gconst8;
j6=x504;
IkReal gconst6=x504;
IkReal gconst7=((-1.0)*new_r01*x505);
IkReal gconst8=(new_r11*x505);
IkReal x507=new_r01*new_r01;
IkReal x508=(new_r00*new_r01);
IkReal x509=(((new_r10*new_r11))+x508);
IkReal x510=x500;
IkReal x511=(new_r01*x510);
j4eval[0]=x509;
j4eval[1]=IKsign(x509);
j4eval[2]=((IKabs((((new_r11*x511))+((x508*x510)))))+(IKabs((((new_r10*x511))+(((-1.0)*x507*x510))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
CheckValue<IkReal> x514 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x514.valid){
continue;
}
IkReal x512=((-1.0)*(x514.value));
IkReal x513=x500;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst7;
cj6=gconst8;
j6=x512;
IkReal gconst6=x512;
IkReal gconst7=((-1.0)*new_r01*x513);
IkReal gconst8=(new_r11*x513);
IkReal x515=((new_r01*new_r01)+(new_r11*new_r11));
j4eval[0]=x515;
j4eval[1]=IKsign(x515);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
CheckValue<IkReal> x518 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x518.valid){
continue;
}
IkReal x516=((-1.0)*(x518.value));
IkReal x517=x500;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst7;
cj6=gconst8;
j6=x516;
IkReal gconst6=x516;
IkReal gconst7=((-1.0)*new_r01*x517);
IkReal gconst8=(new_r11*x517);
IkReal x519=new_r01*new_r01;
IkReal x520=new_r11*new_r11;
IkReal x521=((1.0)*x519);
CheckValue<IkReal> x527=IKPowWithIntegerCheck((x520+x519),-1);
if(!x527.valid){
continue;
}
IkReal x522=x527.value;
CheckValue<IkReal> x528=IKPowWithIntegerCheck(((((-1.0)*x520))+(((-1.0)*x521))),-1);
if(!x528.valid){
continue;
}
IkReal x523=x528.value;
IkReal x524=((1.0)*x523);
IkReal x525=(new_r11*x524);
IkReal x526=(new_r01*x524);
j4eval[0]=((IKabs(((((-1.0)*x521*x522))+((x522*(x520*x520)))+((x519*x520*x522)))))+(IKabs(((((-1.0)*x525*(new_r01*new_r01*new_r01)))+(((-1.0)*new_r01*x525*(new_r11*new_r11)))+(((-1.0)*new_r01*x525))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
CheckValue<IkReal> x530 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x530.valid){
continue;
}
IkReal x529=((-1.0)*(x530.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst7;
cj6=gconst8;
j6=x529;
new_r11=0;
new_r00=0;
IkReal gconst6=x529;
IkReal x531 = new_r01*new_r01;
if(IKabs(x531)==0){
continue;
}
IkReal gconst7=((-1.0)*new_r01*(pow(x531,-0.5)));
IkReal gconst8=0;
j4eval[0]=new_r10;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x532=IKPowWithIntegerCheck(gconst7,-1);
if(!x532.valid){
continue;
}
cj4array[0]=((-1.0)*new_r10*(x532.value));
if( cj4array[0] >= -1-IKFAST_SINCOS_THRESH && cj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x533=IKsin(j4);
IkReal x534=IKcos(j4);
IkReal x535=((-1.0)*x533);
evalcond[0]=(new_r10*x533);
evalcond[1]=(new_r01*x535);
evalcond[2]=(gconst7*x535);
evalcond[3]=(gconst7+((new_r10*x534)));
evalcond[4]=(((new_r01*x534))+gconst7);
evalcond[5]=(((gconst7*x534))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x536=IKPowWithIntegerCheck(new_r10,-1);
if(!x536.valid){
continue;
}
cj4array[0]=((-1.0)*gconst7*(x536.value));
if( cj4array[0] >= -1-IKFAST_SINCOS_THRESH && cj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x537=IKsin(j4);
IkReal x538=IKcos(j4);
IkReal x539=(gconst7*x538);
IkReal x540=((-1.0)*x537);
evalcond[0]=(new_r10*x537);
evalcond[1]=(new_r01*x540);
evalcond[2]=(gconst7*x540);
evalcond[3]=(x539+new_r10);
evalcond[4]=(((new_r01*x538))+gconst7);
evalcond[5]=(x539+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst7;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
CheckValue<IkReal> x542 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x542.valid){
continue;
}
IkReal x541=((-1.0)*(x542.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst7;
cj6=gconst8;
j6=x541;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst6=x541;
IkReal gconst7=((-1.0)*new_r01);
IkReal gconst8=new_r11;
j4eval[0]=-1.0;
j4eval[1]=((IKabs((new_r01*new_r11)))+(IKabs(((1.0)+(((-1.0)*(new_r01*new_r01)))))));
j4eval[2]=-1.0;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
CheckValue<IkReal> x544 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x544.valid){
continue;
}
IkReal x543=((-1.0)*(x544.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst7;
cj6=gconst8;
j6=x543;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst6=x543;
IkReal gconst7=((-1.0)*new_r01);
IkReal gconst8=new_r11;
j4eval[0]=-1.0;
j4eval[1]=((IKabs((new_r01*new_r11)))+(IKabs(((1.0)+(((-1.0)*(new_r01*new_r01)))))));
j4eval[2]=-1.0;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
CheckValue<IkReal> x546 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x546.valid){
continue;
}
IkReal x545=((-1.0)*(x546.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst7;
cj6=gconst8;
j6=x545;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst6=x545;
IkReal gconst7=((-1.0)*new_r01);
IkReal gconst8=new_r11;
j4eval[0]=1.0;
j4eval[1]=((((0.5)*(IKabs(((-1.0)+(((2.0)*(new_r01*new_r01))))))))+(IKabs((new_r01*new_r11))));
j4eval[2]=1.0;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x547=((1.0)*new_r11);
CheckValue<IkReal> x548=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x548.valid){
continue;
}
CheckValue<IkReal> x549 = IKatan2WithCheck(IkReal((((gconst8*new_r01))+(((-1.0)*gconst7*x547)))),IkReal(((((-1.0)*gconst7*new_r01))+(((-1.0)*gconst8*x547)))),IKFAST_ATAN2_MAGTHRESH);
if(!x549.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x548.value)))+(x549.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x550=IKcos(j4);
IkReal x551=IKsin(j4);
IkReal x552=(gconst7*x550);
IkReal x553=(gconst7*x551);
IkReal x554=(gconst8*x550);
IkReal x555=((1.0)*x551);
IkReal x556=(gconst8*x555);
evalcond[0]=((((-1.0)*x556))+x552);
evalcond[1]=(((new_r11*x551))+gconst7+((new_r01*x550)));
evalcond[2]=(x553+x554+new_r11);
evalcond[3]=(((new_r11*x550))+gconst8+(((-1.0)*new_r01*x555)));
evalcond[4]=((((-1.0)*x554))+(((-1.0)*x553)));
evalcond[5]=((((-1.0)*x556))+x552+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x557 = IKatan2WithCheck(IkReal((gconst7*new_r11)),IkReal((gconst8*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x557.valid){
continue;
}
CheckValue<IkReal> x558=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst8*gconst8)))+(((-1.0)*(gconst7*gconst7))))),-1);
if(!x558.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x557.value)+(((1.5707963267949)*(x558.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x559=IKcos(j4);
IkReal x560=IKsin(j4);
IkReal x561=(gconst7*x559);
IkReal x562=(gconst7*x560);
IkReal x563=(gconst8*x559);
IkReal x564=((1.0)*x560);
IkReal x565=(gconst8*x564);
evalcond[0]=(x561+(((-1.0)*x565)));
evalcond[1]=(gconst7+((new_r11*x560))+((new_r01*x559)));
evalcond[2]=(x562+x563+new_r11);
evalcond[3]=(((new_r11*x559))+gconst8+(((-1.0)*new_r01*x564)));
evalcond[4]=((((-1.0)*x563))+(((-1.0)*x562)));
evalcond[5]=(x561+new_r01+(((-1.0)*x565)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x566 = IKatan2WithCheck(IkReal((gconst7*gconst8)),IkReal(gconst8*gconst8),IKFAST_ATAN2_MAGTHRESH);
if(!x566.valid){
continue;
}
CheckValue<IkReal> x567=IKPowWithIntegerCheck(IKsign(((((-1.0)*gconst8*new_r11))+((gconst7*new_r01)))),-1);
if(!x567.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x566.value)+(((1.5707963267949)*(x567.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x568=IKcos(j4);
IkReal x569=IKsin(j4);
IkReal x570=(gconst7*x568);
IkReal x571=(gconst7*x569);
IkReal x572=(gconst8*x568);
IkReal x573=((1.0)*x569);
IkReal x574=(gconst8*x573);
evalcond[0]=((((-1.0)*x574))+x570);
evalcond[1]=(gconst7+((new_r01*x568))+((new_r11*x569)));
evalcond[2]=(x571+x572+new_r11);
evalcond[3]=(gconst8+((new_r11*x568))+(((-1.0)*new_r01*x573)));
evalcond[4]=((((-1.0)*x572))+(((-1.0)*x571)));
evalcond[5]=((((-1.0)*x574))+x570+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x575=IKPowWithIntegerCheck(gconst8,-1);
if(!x575.valid){
continue;
}
cj4array[0]=(new_r00*(x575.value));
if( cj4array[0] >= -1-IKFAST_SINCOS_THRESH && cj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x576=IKsin(j4);
IkReal x577=IKcos(j4);
IkReal x578=((-1.0)*x576);
evalcond[0]=(new_r11*x576);
evalcond[1]=(new_r00*x578);
evalcond[2]=(gconst8*x578);
evalcond[3]=(((new_r11*x577))+gconst8);
evalcond[4]=(((gconst8*x577))+new_r11);
evalcond[5]=(((new_r00*x577))+(((-1.0)*gconst8)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
CheckValue<IkReal> x580 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x580.valid){
continue;
}
IkReal x579=((-1.0)*(x580.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst7;
cj6=gconst8;
j6=x579;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst6=x579;
IkReal gconst7=0;
IkReal x581 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x581)==0){
continue;
}
IkReal gconst8=(new_r11*(pow(x581,-0.5)));
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
CheckValue<IkReal> x583 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x583.valid){
continue;
}
IkReal x582=((-1.0)*(x583.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst7;
cj6=gconst8;
j6=x582;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst6=x582;
IkReal gconst7=0;
IkReal x584 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x584)==0){
continue;
}
IkReal gconst8=(new_r11*(pow(x584,-0.5)));
j4eval[0]=new_r11;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
CheckValue<IkReal> x586 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x586.valid){
continue;
}
IkReal x585=((-1.0)*(x586.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst7;
cj6=gconst8;
j6=x585;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst6=x585;
IkReal gconst7=0;
IkReal x587 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x587)==0){
continue;
}
IkReal gconst8=(new_r11*(pow(x587,-0.5)));
j4eval[0]=new_r10;
j4eval[1]=new_r11;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x588=IKPowWithIntegerCheck(new_r10,-1);
if(!x588.valid){
continue;
}
CheckValue<IkReal> x589=IKPowWithIntegerCheck(new_r11,-1);
if(!x589.valid){
continue;
}
if( IKabs((gconst8*(x588.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst8*(x589.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst8*(x588.value)))+IKsqr(((-1.0)*gconst8*(x589.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((gconst8*(x588.value)), ((-1.0)*gconst8*(x589.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x590=IKcos(j4);
IkReal x591=IKsin(j4);
IkReal x592=(gconst8*x590);
IkReal x593=(gconst8*x591);
evalcond[0]=(new_r10*x590);
evalcond[1]=(new_r11*x591);
evalcond[2]=((-1.0)*x592);
evalcond[3]=((-1.0)*x593);
evalcond[4]=(((new_r11*x590))+gconst8);
evalcond[5]=(x592+new_r11);
evalcond[6]=((((-1.0)*x593))+new_r10);
evalcond[7]=(((new_r10*x591))+(((-1.0)*gconst8)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x594=IKPowWithIntegerCheck(gconst8,-1);
if(!x594.valid){
continue;
}
CheckValue<IkReal> x595=IKPowWithIntegerCheck(new_r11,-1);
if(!x595.valid){
continue;
}
if( IKabs((new_r10*(x594.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst8*(x595.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x594.value)))+IKsqr(((-1.0)*gconst8*(x595.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((new_r10*(x594.value)), ((-1.0)*gconst8*(x595.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x596=IKcos(j4);
IkReal x597=IKsin(j4);
IkReal x598=(gconst8*x596);
IkReal x599=(gconst8*x597);
evalcond[0]=(new_r10*x596);
evalcond[1]=(new_r11*x597);
evalcond[2]=((-1.0)*x598);
evalcond[3]=((-1.0)*x599);
evalcond[4]=(((new_r11*x596))+gconst8);
evalcond[5]=(x598+new_r11);
evalcond[6]=((((-1.0)*x599))+new_r10);
evalcond[7]=(((new_r10*x597))+(((-1.0)*gconst8)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x600 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x600.valid){
continue;
}
CheckValue<IkReal> x601=IKPowWithIntegerCheck(IKsign(gconst8),-1);
if(!x601.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x600.value)+(((1.5707963267949)*(x601.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x602=IKcos(j4);
IkReal x603=IKsin(j4);
IkReal x604=(gconst8*x602);
IkReal x605=(gconst8*x603);
evalcond[0]=(new_r10*x602);
evalcond[1]=(new_r11*x603);
evalcond[2]=((-1.0)*x604);
evalcond[3]=((-1.0)*x605);
evalcond[4]=(gconst8+((new_r11*x602)));
evalcond[5]=(x604+new_r11);
evalcond[6]=((((-1.0)*x605))+new_r10);
evalcond[7]=((((-1.0)*gconst8))+((new_r10*x603)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
CheckValue<IkReal> x607 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x607.valid){
continue;
}
IkReal x606=((-1.0)*(x607.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst7;
cj6=gconst8;
j6=x606;
new_r01=0;
IkReal gconst6=x606;
IkReal gconst7=0;
IkReal x608 = new_r11*new_r11;
if(IKabs(x608)==0){
continue;
}
IkReal gconst8=(new_r11*(pow(x608,-0.5)));
j4eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
CheckValue<IkReal> x610 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x610.valid){
continue;
}
IkReal x609=((-1.0)*(x610.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst7;
cj6=gconst8;
j6=x609;
new_r01=0;
IkReal gconst6=x609;
IkReal gconst7=0;
IkReal x611 = new_r11*new_r11;
if(IKabs(x611)==0){
continue;
}
IkReal gconst8=(new_r11*(pow(x611,-0.5)));
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
CheckValue<IkReal> x613 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x613.valid){
continue;
}
IkReal x612=((-1.0)*(x613.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst7;
cj6=gconst8;
j6=x612;
new_r01=0;
IkReal gconst6=x612;
IkReal gconst7=0;
IkReal x614 = new_r11*new_r11;
if(IKabs(x614)==0){
continue;
}
IkReal gconst8=(new_r11*(pow(x614,-0.5)));
j4eval[0]=new_r11;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x615=IKPowWithIntegerCheck(gconst8,-1);
if(!x615.valid){
continue;
}
CheckValue<IkReal> x616=IKPowWithIntegerCheck(new_r11,-1);
if(!x616.valid){
continue;
}
if( IKabs((new_r10*(x615.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst8*(x616.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x615.value)))+IKsqr(((-1.0)*gconst8*(x616.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((new_r10*(x615.value)), ((-1.0)*gconst8*(x616.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x617=IKsin(j4);
IkReal x618=IKcos(j4);
IkReal x619=((1.0)*gconst8);
evalcond[0]=(new_r11*x617);
evalcond[1]=((-1.0)*gconst8*x617);
evalcond[2]=(gconst8+((new_r11*x618)));
evalcond[3]=(((gconst8*x618))+new_r11);
evalcond[4]=((((-1.0)*x617*x619))+new_r10);
evalcond[5]=((((-1.0)*x618*x619))+new_r00);
evalcond[6]=(((new_r10*x618))+(((-1.0)*new_r00*x617)));
evalcond[7]=(((new_r10*x617))+(((-1.0)*x619))+((new_r00*x618)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x620 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x620.valid){
continue;
}
CheckValue<IkReal> x621=IKPowWithIntegerCheck(IKsign(gconst8),-1);
if(!x621.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x620.value)+(((1.5707963267949)*(x621.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x622=IKsin(j4);
IkReal x623=IKcos(j4);
IkReal x624=((1.0)*gconst8);
evalcond[0]=(new_r11*x622);
evalcond[1]=((-1.0)*gconst8*x622);
evalcond[2]=(gconst8+((new_r11*x623)));
evalcond[3]=(((gconst8*x623))+new_r11);
evalcond[4]=((((-1.0)*x622*x624))+new_r10);
evalcond[5]=((((-1.0)*x623*x624))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x622))+((new_r10*x623)));
evalcond[7]=((((-1.0)*x624))+((new_r00*x623))+((new_r10*x622)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x625=IKPowWithIntegerCheck(IKsign(gconst8),-1);
if(!x625.valid){
continue;
}
CheckValue<IkReal> x626 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x626.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x625.value)))+(x626.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x627=IKsin(j4);
IkReal x628=IKcos(j4);
IkReal x629=((1.0)*gconst8);
evalcond[0]=(new_r11*x627);
evalcond[1]=((-1.0)*gconst8*x627);
evalcond[2]=(gconst8+((new_r11*x628)));
evalcond[3]=(((gconst8*x628))+new_r11);
evalcond[4]=((((-1.0)*x627*x629))+new_r10);
evalcond[5]=((((-1.0)*x628*x629))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x627))+((new_r10*x628)));
evalcond[7]=((((-1.0)*x629))+((new_r00*x628))+((new_r10*x627)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x630=((1.0)*new_r11);
CheckValue<IkReal> x631 = IKatan2WithCheck(IkReal(((((-1.0)*new_r01*x630))+((gconst7*gconst8)))),IkReal(((((-1.0)*(gconst7*gconst7)))+(new_r11*new_r11))),IKFAST_ATAN2_MAGTHRESH);
if(!x631.valid){
continue;
}
CheckValue<IkReal> x632=IKPowWithIntegerCheck(IKsign(((((-1.0)*gconst8*x630))+((gconst7*new_r01)))),-1);
if(!x632.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x631.value)+(((1.5707963267949)*(x632.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x633=IKcos(j4);
IkReal x634=IKsin(j4);
IkReal x635=(gconst7*x633);
IkReal x636=(gconst7*x634);
IkReal x637=(gconst8*x633);
IkReal x638=((1.0)*x634);
IkReal x639=(gconst8*x638);
evalcond[0]=(gconst7+((new_r01*x633))+((new_r11*x634)));
evalcond[1]=(x636+x637+new_r11);
evalcond[2]=((((-1.0)*new_r00*x638))+gconst7+((new_r10*x633)));
evalcond[3]=((((-1.0)*new_r01*x638))+gconst8+((new_r11*x633)));
evalcond[4]=((((-1.0)*x639))+x635+new_r10);
evalcond[5]=((((-1.0)*x639))+x635+new_r01);
evalcond[6]=((((-1.0)*gconst8))+((new_r00*x633))+((new_r10*x634)));
evalcond[7]=((((-1.0)*x637))+(((-1.0)*x636))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x640=((1.0)*new_r11);
CheckValue<IkReal> x641=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x641.valid){
continue;
}
CheckValue<IkReal> x642 = IKatan2WithCheck(IkReal(((((-1.0)*gconst7*x640))+((gconst8*new_r01)))),IkReal(((((-1.0)*gconst7*new_r01))+(((-1.0)*gconst8*x640)))),IKFAST_ATAN2_MAGTHRESH);
if(!x642.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x641.value)))+(x642.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x643=IKcos(j4);
IkReal x644=IKsin(j4);
IkReal x645=(gconst7*x643);
IkReal x646=(gconst7*x644);
IkReal x647=(gconst8*x643);
IkReal x648=((1.0)*x644);
IkReal x649=(gconst8*x648);
evalcond[0]=(gconst7+((new_r11*x644))+((new_r01*x643)));
evalcond[1]=(x647+x646+new_r11);
evalcond[2]=(gconst7+((new_r10*x643))+(((-1.0)*new_r00*x648)));
evalcond[3]=(gconst8+((new_r11*x643))+(((-1.0)*new_r01*x648)));
evalcond[4]=((((-1.0)*x649))+x645+new_r10);
evalcond[5]=((((-1.0)*x649))+x645+new_r01);
evalcond[6]=((((-1.0)*gconst8))+((new_r10*x644))+((new_r00*x643)));
evalcond[7]=((((-1.0)*x647))+(((-1.0)*x646))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x650=((1.0)*gconst7);
CheckValue<IkReal> x651 = IKatan2WithCheck(IkReal(((((-1.0)*new_r10*x650))+((gconst7*new_r01)))),IkReal(((((-1.0)*new_r00*x650))+(((-1.0)*new_r11*x650)))),IKFAST_ATAN2_MAGTHRESH);
if(!x651.valid){
continue;
}
CheckValue<IkReal> x652=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x652.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x651.value)+(((1.5707963267949)*(x652.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x653=IKcos(j4);
IkReal x654=IKsin(j4);
IkReal x655=(gconst7*x653);
IkReal x656=(gconst7*x654);
IkReal x657=(gconst8*x653);
IkReal x658=((1.0)*x654);
IkReal x659=(gconst8*x658);
evalcond[0]=(gconst7+((new_r01*x653))+((new_r11*x654)));
evalcond[1]=(x656+x657+new_r11);
evalcond[2]=(gconst7+(((-1.0)*new_r00*x658))+((new_r10*x653)));
evalcond[3]=(gconst8+(((-1.0)*new_r01*x658))+((new_r11*x653)));
evalcond[4]=((((-1.0)*x659))+x655+new_r10);
evalcond[5]=((((-1.0)*x659))+x655+new_r01);
evalcond[6]=((((-1.0)*gconst8))+((new_r10*x654))+((new_r00*x653)));
evalcond[7]=((((-1.0)*x656))+(((-1.0)*x657))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x661 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x661)==0){
continue;
}
IkReal x660=pow(x661,-0.5);
CheckValue<IkReal> x662 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x662.valid){
continue;
}
IkReal gconst9=((3.14159265358979)+(((-1.0)*(x662.value))));
IkReal gconst10=((1.0)*new_r01*x660);
IkReal gconst11=((-1.0)*new_r11*x660);
CheckValue<IkReal> x663 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x663.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x663.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
CheckValue<IkReal> x666 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x666.valid){
continue;
}
IkReal x664=((1.0)*(x666.value));
IkReal x665=x660;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst10;
cj6=gconst11;
j6=((3.14159265)+(((-1.0)*x664)));
IkReal gconst9=((3.14159265358979)+(((-1.0)*x664)));
IkReal gconst10=((1.0)*new_r01*x665);
IkReal gconst11=((-1.0)*new_r11*x665);
IkReal x667=new_r01*new_r01;
IkReal x668=(((new_r10*new_r11))+((new_r00*new_r01)));
IkReal x669=x660;
IkReal x670=((1.0)*new_r01*x669);
j4eval[0]=x668;
j4eval[1]=((IKabs(((((-1.0)*new_r00*x670))+(((-1.0)*new_r11*x670)))))+(IKabs((((x667*x669))+(((-1.0)*new_r10*x670))))));
j4eval[2]=IKsign(x668);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
CheckValue<IkReal> x673 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x673.valid){
continue;
}
IkReal x671=((1.0)*(x673.value));
IkReal x672=x660;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst10;
cj6=gconst11;
j6=((3.14159265)+(((-1.0)*x671)));
IkReal gconst9=((3.14159265358979)+(((-1.0)*x671)));
IkReal gconst10=((1.0)*new_r01*x672);
IkReal gconst11=((-1.0)*new_r11*x672);
IkReal x674=((new_r01*new_r01)+(new_r11*new_r11));
j4eval[0]=x674;
j4eval[1]=IKsign(x674);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
CheckValue<IkReal> x677 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x677.valid){
continue;
}
IkReal x675=((1.0)*(x677.value));
IkReal x676=x660;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst10;
cj6=gconst11;
j6=((3.14159265)+(((-1.0)*x675)));
IkReal gconst9=((3.14159265358979)+(((-1.0)*x675)));
IkReal gconst10=((1.0)*new_r01*x676);
IkReal gconst11=((-1.0)*new_r11*x676);
IkReal x678=new_r01*new_r01;
IkReal x679=new_r11*new_r11;
IkReal x680=((1.0)*x678);
CheckValue<IkReal> x686=IKPowWithIntegerCheck((x678+x679),-1);
if(!x686.valid){
continue;
}
IkReal x681=x686.value;
CheckValue<IkReal> x687=IKPowWithIntegerCheck(((((-1.0)*x680))+(((-1.0)*x679))),-1);
if(!x687.valid){
continue;
}
IkReal x682=x687.value;
IkReal x683=((1.0)*x682);
IkReal x684=(new_r11*x683);
IkReal x685=(new_r01*x683);
j4eval[0]=((IKabs(((((-1.0)*new_r01*x684))+(((-1.0)*x684*(new_r01*new_r01*new_r01)))+(((-1.0)*new_r01*x684*(new_r11*new_r11))))))+(IKabs(((((-1.0)*x680*x681))+((x681*(x679*x679)))+((x678*x679*x681))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
CheckValue<IkReal> x689 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x689.valid){
continue;
}
IkReal x688=((1.0)*(x689.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst10;
cj6=gconst11;
j6=((3.14159265)+(((-1.0)*x688)));
new_r11=0;
new_r00=0;
IkReal gconst9=((3.14159265358979)+(((-1.0)*x688)));
IkReal x690 = new_r01*new_r01;
if(IKabs(x690)==0){
continue;
}
IkReal gconst10=((1.0)*new_r01*(pow(x690,-0.5)));
IkReal gconst11=0;
j4eval[0]=new_r10;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x691=IKPowWithIntegerCheck(gconst10,-1);
if(!x691.valid){
continue;
}
cj4array[0]=((-1.0)*new_r10*(x691.value));
if( cj4array[0] >= -1-IKFAST_SINCOS_THRESH && cj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x692=IKsin(j4);
IkReal x693=IKcos(j4);
IkReal x694=((-1.0)*x692);
evalcond[0]=(new_r10*x692);
evalcond[1]=(new_r01*x694);
evalcond[2]=(gconst10*x694);
evalcond[3]=(gconst10+((new_r10*x693)));
evalcond[4]=(gconst10+((new_r01*x693)));
evalcond[5]=(((gconst10*x693))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x695=IKPowWithIntegerCheck(new_r10,-1);
if(!x695.valid){
continue;
}
cj4array[0]=((-1.0)*gconst10*(x695.value));
if( cj4array[0] >= -1-IKFAST_SINCOS_THRESH && cj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x696=IKsin(j4);
IkReal x697=IKcos(j4);
IkReal x698=(gconst10*x697);
IkReal x699=((-1.0)*x696);
evalcond[0]=(new_r10*x696);
evalcond[1]=(new_r01*x699);
evalcond[2]=(gconst10*x699);
evalcond[3]=(x698+new_r10);
evalcond[4]=(gconst10+((new_r01*x697)));
evalcond[5]=(x698+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
CheckValue<IkReal> x701 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x701.valid){
continue;
}
IkReal x700=((1.0)*(x701.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst10;
cj6=gconst11;
j6=((3.14159265)+(((-1.0)*x700)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst9=((3.14159265358979)+(((-1.0)*x700)));
IkReal gconst10=((1.0)*new_r01);
IkReal gconst11=((-1.0)*new_r11);
j4eval[0]=1.0;
j4eval[1]=1.0;
j4eval[2]=((IKabs(((1.0)+(((-1.0)*(new_r01*new_r01))))))+(IKabs(((1.0)*new_r01*new_r11))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
CheckValue<IkReal> x703 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x703.valid){
continue;
}
IkReal x702=((1.0)*(x703.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst10;
cj6=gconst11;
j6=((3.14159265)+(((-1.0)*x702)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst9=((3.14159265358979)+(((-1.0)*x702)));
IkReal gconst10=((1.0)*new_r01);
IkReal gconst11=((-1.0)*new_r11);
j4eval[0]=-1.0;
j4eval[1]=-1.0;
j4eval[2]=((IKabs(((-1.0)+(new_r01*new_r01))))+(IKabs(((1.0)*new_r01*new_r11))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
CheckValue<IkReal> x705 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x705.valid){
continue;
}
IkReal x704=((1.0)*(x705.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst10;
cj6=gconst11;
j6=((3.14159265)+(((-1.0)*x704)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst9=((3.14159265358979)+(((-1.0)*x704)));
IkReal gconst10=((1.0)*new_r01);
IkReal gconst11=((-1.0)*new_r11);
j4eval[0]=1.0;
j4eval[1]=1.0;
j4eval[2]=((IKabs(((2.0)*new_r01*new_r11)))+(IKabs(((1.0)+(((-2.0)*(new_r01*new_r01)))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x706=((1.0)*new_r11);
CheckValue<IkReal> x707 = IKatan2WithCheck(IkReal((((gconst11*new_r01))+(((-1.0)*gconst10*x706)))),IkReal(((((-1.0)*gconst11*x706))+(((-1.0)*gconst10*new_r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x707.valid){
continue;
}
CheckValue<IkReal> x708=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x708.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x707.value)+(((1.5707963267949)*(x708.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x709=IKcos(j4);
IkReal x710=IKsin(j4);
IkReal x711=(gconst10*x709);
IkReal x712=(gconst10*x710);
IkReal x713=(gconst11*x709);
IkReal x714=((1.0)*x710);
IkReal x715=(gconst11*x714);
evalcond[0]=((((-1.0)*x715))+x711);
evalcond[1]=(((new_r01*x709))+gconst10+((new_r11*x710)));
evalcond[2]=(x713+x712+new_r11);
evalcond[3]=(gconst11+((new_r11*x709))+(((-1.0)*new_r01*x714)));
evalcond[4]=((((-1.0)*x713))+(((-1.0)*x712)));
evalcond[5]=((((-1.0)*x715))+x711+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x716=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst11*gconst11)))+(((-1.0)*(gconst10*gconst10))))),-1);
if(!x716.valid){
continue;
}
CheckValue<IkReal> x717 = IKatan2WithCheck(IkReal((gconst10*new_r11)),IkReal((gconst11*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x717.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x716.value)))+(x717.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x718=IKcos(j4);
IkReal x719=IKsin(j4);
IkReal x720=(gconst10*x718);
IkReal x721=(gconst10*x719);
IkReal x722=(gconst11*x718);
IkReal x723=((1.0)*x719);
IkReal x724=(gconst11*x723);
evalcond[0]=((((-1.0)*x724))+x720);
evalcond[1]=(((new_r01*x718))+gconst10+((new_r11*x719)));
evalcond[2]=(x721+x722+new_r11);
evalcond[3]=(gconst11+((new_r11*x718))+(((-1.0)*new_r01*x723)));
evalcond[4]=((((-1.0)*x722))+(((-1.0)*x721)));
evalcond[5]=((((-1.0)*x724))+x720+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x725=IKPowWithIntegerCheck(IKsign((((gconst10*new_r01))+(((-1.0)*gconst11*new_r11)))),-1);
if(!x725.valid){
continue;
}
CheckValue<IkReal> x726 = IKatan2WithCheck(IkReal((gconst10*gconst11)),IkReal(gconst11*gconst11),IKFAST_ATAN2_MAGTHRESH);
if(!x726.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x725.value)))+(x726.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x727=IKcos(j4);
IkReal x728=IKsin(j4);
IkReal x729=(gconst10*x727);
IkReal x730=(gconst10*x728);
IkReal x731=(gconst11*x727);
IkReal x732=((1.0)*x728);
IkReal x733=(gconst11*x732);
evalcond[0]=((((-1.0)*x733))+x729);
evalcond[1]=(gconst10+((new_r01*x727))+((new_r11*x728)));
evalcond[2]=(x731+x730+new_r11);
evalcond[3]=(gconst11+(((-1.0)*new_r01*x732))+((new_r11*x727)));
evalcond[4]=((((-1.0)*x731))+(((-1.0)*x730)));
evalcond[5]=((((-1.0)*x733))+x729+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x734=IKPowWithIntegerCheck(gconst11,-1);
if(!x734.valid){
continue;
}
cj4array[0]=(new_r00*(x734.value));
if( cj4array[0] >= -1-IKFAST_SINCOS_THRESH && cj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x735=IKsin(j4);
IkReal x736=IKcos(j4);
IkReal x737=((-1.0)*x735);
evalcond[0]=(new_r11*x735);
evalcond[1]=(new_r00*x737);
evalcond[2]=(gconst11*x737);
evalcond[3]=(gconst11+((new_r11*x736)));
evalcond[4]=(new_r11+((gconst11*x736)));
evalcond[5]=(((new_r00*x736))+(((-1.0)*gconst11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
CheckValue<IkReal> x739 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x739.valid){
continue;
}
IkReal x738=((1.0)*(x739.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst10;
cj6=gconst11;
j6=((3.14159265)+(((-1.0)*x738)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst9=((3.14159265358979)+(((-1.0)*x738)));
IkReal gconst10=0;
IkReal x740 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x740)==0){
continue;
}
IkReal gconst11=((-1.0)*new_r11*(pow(x740,-0.5)));
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
CheckValue<IkReal> x742 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x742.valid){
continue;
}
IkReal x741=((1.0)*(x742.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst10;
cj6=gconst11;
j6=((3.14159265)+(((-1.0)*x741)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst9=((3.14159265358979)+(((-1.0)*x741)));
IkReal gconst10=0;
IkReal x743 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x743)==0){
continue;
}
IkReal gconst11=((-1.0)*new_r11*(pow(x743,-0.5)));
j4eval[0]=new_r11;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
CheckValue<IkReal> x745 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x745.valid){
continue;
}
IkReal x744=((1.0)*(x745.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst10;
cj6=gconst11;
j6=((3.14159265)+(((-1.0)*x744)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst9=((3.14159265358979)+(((-1.0)*x744)));
IkReal gconst10=0;
IkReal x746 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x746)==0){
continue;
}
IkReal gconst11=((-1.0)*new_r11*(pow(x746,-0.5)));
j4eval[0]=new_r10;
j4eval[1]=new_r11;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x747=IKPowWithIntegerCheck(new_r10,-1);
if(!x747.valid){
continue;
}
CheckValue<IkReal> x748=IKPowWithIntegerCheck(new_r11,-1);
if(!x748.valid){
continue;
}
if( IKabs((gconst11*(x747.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst11*(x748.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst11*(x747.value)))+IKsqr(((-1.0)*gconst11*(x748.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((gconst11*(x747.value)), ((-1.0)*gconst11*(x748.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x749=IKcos(j4);
IkReal x750=IKsin(j4);
IkReal x751=(gconst11*x749);
IkReal x752=(gconst11*x750);
evalcond[0]=(new_r10*x749);
evalcond[1]=(new_r11*x750);
evalcond[2]=((-1.0)*x751);
evalcond[3]=((-1.0)*x752);
evalcond[4]=(gconst11+((new_r11*x749)));
evalcond[5]=(x751+new_r11);
evalcond[6]=((((-1.0)*x752))+new_r10);
evalcond[7]=(((new_r10*x750))+(((-1.0)*gconst11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x753=IKPowWithIntegerCheck(gconst11,-1);
if(!x753.valid){
continue;
}
CheckValue<IkReal> x754=IKPowWithIntegerCheck(new_r11,-1);
if(!x754.valid){
continue;
}
if( IKabs((new_r10*(x753.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst11*(x754.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x753.value)))+IKsqr(((-1.0)*gconst11*(x754.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((new_r10*(x753.value)), ((-1.0)*gconst11*(x754.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x755=IKcos(j4);
IkReal x756=IKsin(j4);
IkReal x757=(gconst11*x755);
IkReal x758=(gconst11*x756);
evalcond[0]=(new_r10*x755);
evalcond[1]=(new_r11*x756);
evalcond[2]=((-1.0)*x757);
evalcond[3]=((-1.0)*x758);
evalcond[4]=(gconst11+((new_r11*x755)));
evalcond[5]=(x757+new_r11);
evalcond[6]=((((-1.0)*x758))+new_r10);
evalcond[7]=(((new_r10*x756))+(((-1.0)*gconst11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x759=IKPowWithIntegerCheck(IKsign(gconst11),-1);
if(!x759.valid){
continue;
}
CheckValue<IkReal> x760 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x760.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x759.value)))+(x760.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x761=IKcos(j4);
IkReal x762=IKsin(j4);
IkReal x763=(gconst11*x761);
IkReal x764=(gconst11*x762);
evalcond[0]=(new_r10*x761);
evalcond[1]=(new_r11*x762);
evalcond[2]=((-1.0)*x763);
evalcond[3]=((-1.0)*x764);
evalcond[4]=(((new_r11*x761))+gconst11);
evalcond[5]=(x763+new_r11);
evalcond[6]=((((-1.0)*x764))+new_r10);
evalcond[7]=(((new_r10*x762))+(((-1.0)*gconst11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
CheckValue<IkReal> x766 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x766.valid){
continue;
}
IkReal x765=((1.0)*(x766.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst10;
cj6=gconst11;
j6=((3.14159265)+(((-1.0)*x765)));
new_r01=0;
IkReal gconst9=((3.14159265358979)+(((-1.0)*x765)));
IkReal gconst10=0;
IkReal x767 = new_r11*new_r11;
if(IKabs(x767)==0){
continue;
}
IkReal gconst11=((-1.0)*new_r11*(pow(x767,-0.5)));
j4eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
CheckValue<IkReal> x769 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x769.valid){
continue;
}
IkReal x768=((1.0)*(x769.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst10;
cj6=gconst11;
j6=((3.14159265)+(((-1.0)*x768)));
new_r01=0;
IkReal gconst9=((3.14159265358979)+(((-1.0)*x768)));
IkReal gconst10=0;
IkReal x770 = new_r11*new_r11;
if(IKabs(x770)==0){
continue;
}
IkReal gconst11=((-1.0)*new_r11*(pow(x770,-0.5)));
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
CheckValue<IkReal> x772 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x772.valid){
continue;
}
IkReal x771=((1.0)*(x772.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst10;
cj6=gconst11;
j6=((3.14159265)+(((-1.0)*x771)));
new_r01=0;
IkReal gconst9=((3.14159265358979)+(((-1.0)*x771)));
IkReal gconst10=0;
IkReal x773 = new_r11*new_r11;
if(IKabs(x773)==0){
continue;
}
IkReal gconst11=((-1.0)*new_r11*(pow(x773,-0.5)));
j4eval[0]=new_r11;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x774=IKPowWithIntegerCheck(gconst11,-1);
if(!x774.valid){
continue;
}
CheckValue<IkReal> x775=IKPowWithIntegerCheck(new_r11,-1);
if(!x775.valid){
continue;
}
if( IKabs((new_r10*(x774.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst11*(x775.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x774.value)))+IKsqr(((-1.0)*gconst11*(x775.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((new_r10*(x774.value)), ((-1.0)*gconst11*(x775.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x776=IKsin(j4);
IkReal x777=IKcos(j4);
IkReal x778=((1.0)*x776);
IkReal x779=(gconst11*x777);
evalcond[0]=(new_r11*x776);
evalcond[1]=((-1.0)*gconst11*x776);
evalcond[2]=(gconst11+((new_r11*x777)));
evalcond[3]=(x779+new_r11);
evalcond[4]=((((-1.0)*gconst11*x778))+new_r10);
evalcond[5]=(new_r00+(((-1.0)*x779)));
evalcond[6]=((((-1.0)*new_r00*x778))+((new_r10*x777)));
evalcond[7]=(((new_r00*x777))+((new_r10*x776))+(((-1.0)*gconst11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x780=IKPowWithIntegerCheck(IKsign(gconst11),-1);
if(!x780.valid){
continue;
}
CheckValue<IkReal> x781 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x781.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x780.value)))+(x781.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x782=IKsin(j4);
IkReal x783=IKcos(j4);
IkReal x784=((1.0)*x782);
IkReal x785=(gconst11*x783);
evalcond[0]=(new_r11*x782);
evalcond[1]=((-1.0)*gconst11*x782);
evalcond[2]=(((new_r11*x783))+gconst11);
evalcond[3]=(x785+new_r11);
evalcond[4]=((((-1.0)*gconst11*x784))+new_r10);
evalcond[5]=((((-1.0)*x785))+new_r00);
evalcond[6]=(((new_r10*x783))+(((-1.0)*new_r00*x784)));
evalcond[7]=(((new_r10*x782))+((new_r00*x783))+(((-1.0)*gconst11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x786=IKPowWithIntegerCheck(IKsign(gconst11),-1);
if(!x786.valid){
continue;
}
CheckValue<IkReal> x787 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x787.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x786.value)))+(x787.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x788=IKsin(j4);
IkReal x789=IKcos(j4);
IkReal x790=((1.0)*x788);
IkReal x791=(gconst11*x789);
evalcond[0]=(new_r11*x788);
evalcond[1]=((-1.0)*gconst11*x788);
evalcond[2]=(((new_r11*x789))+gconst11);
evalcond[3]=(x791+new_r11);
evalcond[4]=((((-1.0)*gconst11*x790))+new_r10);
evalcond[5]=((((-1.0)*x791))+new_r00);
evalcond[6]=(((new_r10*x789))+(((-1.0)*new_r00*x790)));
evalcond[7]=(((new_r10*x788))+((new_r00*x789))+(((-1.0)*gconst11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x792=((1.0)*new_r11);
CheckValue<IkReal> x793=IKPowWithIntegerCheck(IKsign(((((-1.0)*gconst11*x792))+((gconst10*new_r01)))),-1);
if(!x793.valid){
continue;
}
CheckValue<IkReal> x794 = IKatan2WithCheck(IkReal(((((-1.0)*new_r01*x792))+((gconst10*gconst11)))),IkReal(((new_r11*new_r11)+(((-1.0)*(gconst10*gconst10))))),IKFAST_ATAN2_MAGTHRESH);
if(!x794.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x793.value)))+(x794.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x795=IKcos(j4);
IkReal x796=IKsin(j4);
IkReal x797=((1.0)*gconst11);
IkReal x798=(gconst10*x795);
IkReal x799=(gconst10*x796);
IkReal x800=((1.0)*x796);
IkReal x801=(x796*x797);
evalcond[0]=(((new_r11*x796))+gconst10+((new_r01*x795)));
evalcond[1]=(((gconst11*x795))+x799+new_r11);
evalcond[2]=(((new_r10*x795))+(((-1.0)*new_r00*x800))+gconst10);
evalcond[3]=((((-1.0)*new_r01*x800))+((new_r11*x795))+gconst11);
evalcond[4]=(x798+new_r10+(((-1.0)*x801)));
evalcond[5]=(x798+new_r01+(((-1.0)*x801)));
evalcond[6]=((((-1.0)*x797))+((new_r10*x796))+((new_r00*x795)));
evalcond[7]=((((-1.0)*x795*x797))+(((-1.0)*x799))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x802=((1.0)*new_r11);
CheckValue<IkReal> x803 = IKatan2WithCheck(IkReal((((gconst11*new_r01))+(((-1.0)*gconst10*x802)))),IkReal(((((-1.0)*gconst11*x802))+(((-1.0)*gconst10*new_r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x803.valid){
continue;
}
CheckValue<IkReal> x804=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x804.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x803.value)+(((1.5707963267949)*(x804.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x805=IKcos(j4);
IkReal x806=IKsin(j4);
IkReal x807=((1.0)*gconst11);
IkReal x808=(gconst10*x805);
IkReal x809=(gconst10*x806);
IkReal x810=((1.0)*x806);
IkReal x811=(x806*x807);
evalcond[0]=(gconst10+((new_r11*x806))+((new_r01*x805)));
evalcond[1]=(new_r11+x809+((gconst11*x805)));
evalcond[2]=(gconst10+(((-1.0)*new_r00*x810))+((new_r10*x805)));
evalcond[3]=(gconst11+(((-1.0)*new_r01*x810))+((new_r11*x805)));
evalcond[4]=((((-1.0)*x811))+new_r10+x808);
evalcond[5]=((((-1.0)*x811))+new_r01+x808);
evalcond[6]=(((new_r00*x805))+((new_r10*x806))+(((-1.0)*x807)));
evalcond[7]=((((-1.0)*x809))+(((-1.0)*x805*x807))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x812=((1.0)*gconst10);
CheckValue<IkReal> x813 = IKatan2WithCheck(IkReal(((((-1.0)*new_r10*x812))+((gconst10*new_r01)))),IkReal(((((-1.0)*new_r11*x812))+(((-1.0)*new_r00*x812)))),IKFAST_ATAN2_MAGTHRESH);
if(!x813.valid){
continue;
}
CheckValue<IkReal> x814=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x814.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x813.value)+(((1.5707963267949)*(x814.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x815=IKcos(j4);
IkReal x816=IKsin(j4);
IkReal x817=((1.0)*gconst11);
IkReal x818=(gconst10*x815);
IkReal x819=(gconst10*x816);
IkReal x820=((1.0)*x816);
IkReal x821=(x816*x817);
evalcond[0]=(((new_r11*x816))+((new_r01*x815))+gconst10);
evalcond[1]=(((gconst11*x815))+new_r11+x819);
evalcond[2]=(((new_r10*x815))+gconst10+(((-1.0)*new_r00*x820)));
evalcond[3]=(((new_r11*x815))+gconst11+(((-1.0)*new_r01*x820)));
evalcond[4]=((((-1.0)*x821))+new_r10+x818);
evalcond[5]=((((-1.0)*x821))+new_r01+x818);
evalcond[6]=(((new_r00*x815))+((new_r10*x816))+(((-1.0)*x817)));
evalcond[7]=((((-1.0)*x815*x817))+(((-1.0)*x819))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((new_r01*new_r01)+(new_r11*new_r11));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
new_r01=0;
new_r11=0;
j4eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x823 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x823.valid){
continue;
}
IkReal x822=x823.value;
j4array[0]=((-1.0)*x822);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x822)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
evalcond[0]=(((new_r10*(IKcos(j4))))+(((-1.0)*new_r00*(IKsin(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j6))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r10, ((-1.0)*new_r11));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x824=IKcos(j4);
IkReal x825=IKsin(j4);
IkReal x826=((1.0)*x825);
evalcond[0]=(new_r11+x824);
evalcond[1]=((((-1.0)*x826))+new_r10);
evalcond[2]=((((-1.0)*x824))+new_r00);
evalcond[3]=((((-1.0)*x826))+new_r01);
evalcond[4]=(((new_r01*x824))+((new_r11*x825)));
evalcond[5]=(((new_r10*x824))+(((-1.0)*new_r00*x826)));
evalcond[6]=((-1.0)+((new_r10*x825))+((new_r00*x824)));
evalcond[7]=((1.0)+((new_r11*x824))+(((-1.0)*new_r01*x826)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r00));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x827=IKsin(j4);
IkReal x828=IKcos(j4);
IkReal x829=((1.0)*x827);
evalcond[0]=(new_r10+x827);
evalcond[1]=(new_r00+x828);
evalcond[2]=(new_r01+x827);
evalcond[3]=((((-1.0)*x828))+new_r11);
evalcond[4]=(((new_r01*x828))+((new_r11*x827)));
evalcond[5]=(((new_r10*x828))+(((-1.0)*new_r00*x829)));
evalcond[6]=((1.0)+((new_r10*x827))+((new_r00*x828)));
evalcond[7]=((-1.0)+((new_r11*x828))+(((-1.0)*new_r01*x829)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
new_r11=0;
new_r00=0;
j4eval[0]=new_r01;
j4eval[1]=IKsign(new_r01);
j4eval[2]=((IKabs(cj6))+(IKabs(sj6)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
new_r11=0;
new_r00=0;
j4eval[0]=new_r10;
j4eval[1]=IKsign(new_r10);
j4eval[2]=((IKabs(cj6))+(IKabs(sj6)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
new_r11=0;
new_r00=0;
j4eval[0]=new_r01;
j4eval[1]=new_r10;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x830=IKPowWithIntegerCheck(new_r01,-1);
if(!x830.valid){
continue;
}
CheckValue<IkReal> x831=IKPowWithIntegerCheck(new_r10,-1);
if(!x831.valid){
continue;
}
if( IKabs((cj6*(x830.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*sj6*(x831.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((cj6*(x830.value)))+IKsqr(((-1.0)*sj6*(x831.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((cj6*(x830.value)), ((-1.0)*sj6*(x831.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[7];
IkReal x832=IKcos(j4);
IkReal x833=IKsin(j4);
IkReal x834=((1.0)*cj6);
IkReal x835=(sj6*x832);
IkReal x836=((1.0)*x833);
IkReal x837=(x833*x834);
evalcond[0]=(sj6+((new_r10*x832)));
evalcond[1]=(sj6+((new_r01*x832)));
evalcond[2]=(cj6+(((-1.0)*new_r01*x836)));
evalcond[3]=((((-1.0)*x834))+((new_r10*x833)));
evalcond[4]=((((-1.0)*x837))+new_r10+x835);
evalcond[5]=((((-1.0)*x832*x834))+(((-1.0)*sj6*x836)));
evalcond[6]=((((-1.0)*x837))+new_r01+x835);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x838 = IKatan2WithCheck(IkReal(cj6),IkReal(((-1.0)*sj6)),IKFAST_ATAN2_MAGTHRESH);
if(!x838.valid){
continue;
}
CheckValue<IkReal> x839=IKPowWithIntegerCheck(IKsign(new_r10),-1);
if(!x839.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x838.value)+(((1.5707963267949)*(x839.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[7];
IkReal x840=IKcos(j4);
IkReal x841=IKsin(j4);
IkReal x842=((1.0)*cj6);
IkReal x843=(sj6*x840);
IkReal x844=((1.0)*x841);
IkReal x845=(x841*x842);
evalcond[0]=(((new_r10*x840))+sj6);
evalcond[1]=(sj6+((new_r01*x840)));
evalcond[2]=(cj6+(((-1.0)*new_r01*x844)));
evalcond[3]=(((new_r10*x841))+(((-1.0)*x842)));
evalcond[4]=((((-1.0)*x845))+new_r10+x843);
evalcond[5]=((((-1.0)*x840*x842))+(((-1.0)*sj6*x844)));
evalcond[6]=((((-1.0)*x845))+new_r01+x843);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x846=IKPowWithIntegerCheck(IKsign(new_r01),-1);
if(!x846.valid){
continue;
}
CheckValue<IkReal> x847 = IKatan2WithCheck(IkReal(cj6),IkReal(((-1.0)*sj6)),IKFAST_ATAN2_MAGTHRESH);
if(!x847.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x846.value)))+(x847.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[7];
IkReal x848=IKcos(j4);
IkReal x849=IKsin(j4);
IkReal x850=((1.0)*cj6);
IkReal x851=(sj6*x848);
IkReal x852=((1.0)*x849);
IkReal x853=(x849*x850);
evalcond[0]=(((new_r10*x848))+sj6);
evalcond[1]=(sj6+((new_r01*x848)));
evalcond[2]=(cj6+(((-1.0)*new_r01*x852)));
evalcond[3]=(((new_r10*x849))+(((-1.0)*x850)));
evalcond[4]=((((-1.0)*x853))+new_r10+x851);
evalcond[5]=((((-1.0)*sj6*x852))+(((-1.0)*x848*x850)));
evalcond[6]=((((-1.0)*x853))+new_r01+x851);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
new_r11=0;
new_r01=0;
new_r22=0;
new_r20=0;
j4eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x855 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x855.valid){
continue;
}
IkReal x854=x855.value;
j4array[0]=((-1.0)*x854);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x854)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
evalcond[0]=(((new_r10*(IKcos(j4))))+(((-1.0)*new_r00*(IKsin(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x857 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x857.valid){
continue;
}
IkReal x856=x857.value;
j4array[0]=((-1.0)*x856);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x856)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
evalcond[0]=(((new_r11*(IKcos(j4))))+(((-1.0)*new_r01*(IKsin(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
new_r01=0;
new_r10=0;
j4eval[0]=new_r11;
j4eval[1]=IKsign(new_r11);
j4eval[2]=((IKabs(cj6))+(IKabs(sj6)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
new_r01=0;
new_r10=0;
j4eval[0]=new_r00;
j4eval[1]=new_r11;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x858=IKPowWithIntegerCheck(new_r00,-1);
if(!x858.valid){
continue;
}
CheckValue<IkReal> x859=IKPowWithIntegerCheck(new_r11,-1);
if(!x859.valid){
continue;
}
if( IKabs((sj6*(x858.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*cj6*(x859.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((sj6*(x858.value)))+IKsqr(((-1.0)*cj6*(x859.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((sj6*(x858.value)), ((-1.0)*cj6*(x859.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[7];
IkReal x860=IKsin(j4);
IkReal x861=IKcos(j4);
IkReal x862=((1.0)*cj6);
IkReal x863=(sj6*x860);
evalcond[0]=(cj6+((new_r11*x861)));
evalcond[1]=(sj6+((new_r11*x860)));
evalcond[2]=(sj6+(((-1.0)*new_r00*x860)));
evalcond[3]=((((-1.0)*x862))+((new_r00*x861)));
evalcond[4]=((((-1.0)*x860*x862))+((sj6*x861)));
evalcond[5]=(((cj6*x861))+new_r11+x863);
evalcond[6]=((((-1.0)*x863))+(((-1.0)*x861*x862))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x864=IKPowWithIntegerCheck(IKsign(new_r11),-1);
if(!x864.valid){
continue;
}
CheckValue<IkReal> x865 = IKatan2WithCheck(IkReal(((-1.0)*sj6)),IkReal(((-1.0)*cj6)),IKFAST_ATAN2_MAGTHRESH);
if(!x865.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x864.value)))+(x865.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[7];
IkReal x866=IKsin(j4);
IkReal x867=IKcos(j4);
IkReal x868=((1.0)*cj6);
IkReal x869=(sj6*x866);
evalcond[0]=(cj6+((new_r11*x867)));
evalcond[1]=(sj6+((new_r11*x866)));
evalcond[2]=(sj6+(((-1.0)*new_r00*x866)));
evalcond[3]=((((-1.0)*x868))+((new_r00*x867)));
evalcond[4]=((((-1.0)*x866*x868))+((sj6*x867)));
evalcond[5]=(((cj6*x867))+new_r11+x869);
evalcond[6]=((((-1.0)*x869))+new_r00+(((-1.0)*x867*x868)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x870 = IKatan2WithCheck(IkReal(((-1.0)+((new_r01*new_r10))+(cj6*cj6))),IkReal(((((-1.0)*cj6*sj6))+(((-1.0)*new_r10*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x870.valid){
continue;
}
CheckValue<IkReal> x871=IKPowWithIntegerCheck(IKsign((((new_r11*sj6))+((cj6*new_r01)))),-1);
if(!x871.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x870.value)+(((1.5707963267949)*(x871.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x872=IKsin(j4);
IkReal x873=IKcos(j4);
IkReal x874=((1.0)*cj6);
IkReal x875=(sj6*x873);
IkReal x876=(sj6*x872);
IkReal x877=((1.0)*x872);
IkReal x878=(x872*x874);
evalcond[0]=(((new_r01*x873))+sj6+((new_r11*x872)));
evalcond[1]=(((cj6*x873))+new_r11+x876);
evalcond[2]=(sj6+(((-1.0)*new_r00*x877))+((new_r10*x873)));
evalcond[3]=(cj6+(((-1.0)*new_r01*x877))+((new_r11*x873)));
evalcond[4]=(new_r10+x875+(((-1.0)*x878)));
evalcond[5]=(new_r01+x875+(((-1.0)*x878)));
evalcond[6]=(((new_r00*x873))+((new_r10*x872))+(((-1.0)*x874)));
evalcond[7]=((((-1.0)*x876))+(((-1.0)*x873*x874))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x879=((1.0)*sj6);
CheckValue<IkReal> x880=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x880.valid){
continue;
}
CheckValue<IkReal> x881 = IKatan2WithCheck(IkReal((((cj6*new_r01))+(((-1.0)*new_r11*x879)))),IkReal(((((-1.0)*cj6*new_r11))+(((-1.0)*new_r01*x879)))),IKFAST_ATAN2_MAGTHRESH);
if(!x881.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x880.value)))+(x881.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x882=IKsin(j4);
IkReal x883=IKcos(j4);
IkReal x884=((1.0)*cj6);
IkReal x885=(sj6*x883);
IkReal x886=(sj6*x882);
IkReal x887=((1.0)*x882);
IkReal x888=(x882*x884);
evalcond[0]=(sj6+((new_r01*x883))+((new_r11*x882)));
evalcond[1]=(new_r11+x886+((cj6*x883)));
evalcond[2]=(sj6+((new_r10*x883))+(((-1.0)*new_r00*x887)));
evalcond[3]=(cj6+((new_r11*x883))+(((-1.0)*new_r01*x887)));
evalcond[4]=((((-1.0)*x888))+new_r10+x885);
evalcond[5]=((((-1.0)*x888))+new_r01+x885);
evalcond[6]=(((new_r10*x882))+((new_r00*x883))+(((-1.0)*x884)));
evalcond[7]=((((-1.0)*x883*x884))+(((-1.0)*x886))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x889=((1.0)*sj6);
CheckValue<IkReal> x890 = IKatan2WithCheck(IkReal(((((-1.0)*new_r10*x889))+((new_r01*sj6)))),IkReal(((((-1.0)*new_r11*x889))+(((-1.0)*new_r00*x889)))),IKFAST_ATAN2_MAGTHRESH);
if(!x890.valid){
continue;
}
CheckValue<IkReal> x891=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x891.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x890.value)+(((1.5707963267949)*(x891.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x892=IKsin(j4);
IkReal x893=IKcos(j4);
IkReal x894=((1.0)*cj6);
IkReal x895=(sj6*x893);
IkReal x896=(sj6*x892);
IkReal x897=((1.0)*x892);
IkReal x898=(x892*x894);
evalcond[0]=(sj6+((new_r11*x892))+((new_r01*x893)));
evalcond[1]=(new_r11+x896+((cj6*x893)));
evalcond[2]=(sj6+((new_r10*x893))+(((-1.0)*new_r00*x897)));
evalcond[3]=(((new_r11*x893))+cj6+(((-1.0)*new_r01*x897)));
evalcond[4]=((((-1.0)*x898))+new_r10+x895);
evalcond[5]=((((-1.0)*x898))+new_r01+x895);
evalcond[6]=(((new_r00*x893))+((new_r10*x892))+(((-1.0)*x894)));
evalcond[7]=((((-1.0)*x896))+(((-1.0)*x893*x894))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=((IKabs((new_r11*new_r22)))+(IKabs((new_r01*new_r22))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x899=((-1.0)*new_r22);
CheckValue<IkReal> x901 = IKatan2WithCheck(IkReal((new_r01*x899)),IkReal((new_r11*x899)),IKFAST_ATAN2_MAGTHRESH);
if(!x901.valid){
continue;
}
IkReal x900=x901.value;
j4array[0]=((-1.0)*x900);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x900)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x902=IKcos(j4);
IkReal x903=IKsin(j4);
IkReal x904=((1.0)*new_r22);
IkReal x905=(new_r00*x902);
IkReal x906=(new_r10*x903);
IkReal x907=((1.0)*x903);
evalcond[0]=(x905+x906);
evalcond[1]=(((new_r11*x903))+((new_r01*x902)));
evalcond[2]=(((new_r10*x902))+(((-1.0)*new_r00*x907)));
evalcond[3]=(((new_r11*x902))+(((-1.0)*new_r01*x907)));
evalcond[4]=((((-1.0)*x904*x905))+(((-1.0)*x904*x906)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x909 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x909.valid){
continue;
}
IkReal x908=x909.value;
j4array[0]=((-1.0)*x908);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x908)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x910=IKcos(j4);
IkReal x911=IKsin(j4);
IkReal x912=((1.0)*new_r22);
IkReal x913=(new_r00*x910);
IkReal x914=(new_r10*x911);
IkReal x915=((1.0)*x911);
evalcond[0]=(x913+x914);
evalcond[1]=(((new_r10*x910))+(((-1.0)*new_r00*x915)));
evalcond[2]=(((new_r11*x910))+(((-1.0)*new_r01*x915)));
evalcond[3]=((((-1.0)*new_r11*x911*x912))+(((-1.0)*new_r01*x910*x912)));
evalcond[4]=((((-1.0)*x912*x914))+(((-1.0)*x912*x913)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x917 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x917.valid){
continue;
}
IkReal x916=x917.value;
j4array[0]=((-1.0)*x916);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x916)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x918=IKcos(j4);
IkReal x919=IKsin(j4);
IkReal x920=((1.0)*new_r22);
IkReal x921=(new_r01*x918);
IkReal x922=(new_r11*x919);
IkReal x923=((1.0)*x919);
evalcond[0]=(x922+x921);
evalcond[1]=(((new_r10*x918))+(((-1.0)*new_r00*x923)));
evalcond[2]=(((new_r11*x918))+(((-1.0)*new_r01*x923)));
evalcond[3]=((((-1.0)*x920*x922))+(((-1.0)*x920*x921)));
evalcond[4]=((((-1.0)*new_r10*x919*x920))+(((-1.0)*new_r00*x918*x920)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x925=IKPowWithIntegerCheck(sj5,-1);
if(!x925.valid){
continue;
}
IkReal x924=x925.value;
CheckValue<IkReal> x926=IKPowWithIntegerCheck(new_r00,-1);
if(!x926.valid){
continue;
}
if( IKabs((x924*(x926.value)*((((sj5*sj6))+((new_r02*new_r10)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x924)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x924*(x926.value)*((((sj5*sj6))+((new_r02*new_r10))))))+IKsqr((new_r02*x924))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x924*(x926.value)*((((sj5*sj6))+((new_r02*new_r10))))), (new_r02*x924));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[18];
IkReal x927=IKcos(j4);
IkReal x928=IKsin(j4);
IkReal x929=((1.0)*sj5);
IkReal x930=(cj5*cj6);
IkReal x931=(cj5*sj6);
IkReal x932=(new_r11*x928);
IkReal x933=((1.0)*x928);
IkReal x934=(new_r02*x927);
IkReal x935=(new_r12*x928);
IkReal x936=(sj5*x927);
IkReal x937=(new_r10*x928);
IkReal x938=((1.0)*cj5*x927);
evalcond[0]=((((-1.0)*x927*x929))+new_r02);
evalcond[1]=((((-1.0)*x928*x929))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x933))+((new_r12*x927)));
evalcond[3]=(sj6+(((-1.0)*new_r00*x933))+((new_r10*x927)));
evalcond[4]=(cj6+(((-1.0)*new_r01*x933))+((new_r11*x927)));
evalcond[5]=(((x928*x930))+new_r10+((sj6*x927)));
evalcond[6]=((((-1.0)*x929))+x935+x934);
evalcond[7]=(((new_r00*x927))+x937+x930);
evalcond[8]=(((x927*x930))+new_r00+(((-1.0)*sj6*x933)));
evalcond[9]=((((-1.0)*x931*x933))+((cj6*x927))+new_r11);
evalcond[10]=(((new_r01*x927))+(((-1.0)*x931))+x932);
evalcond[11]=((((-1.0)*cj6*x933))+new_r01+(((-1.0)*x927*x931)));
evalcond[12]=(((cj5*new_r20))+((new_r00*x936))+((sj5*x937)));
evalcond[13]=(((cj5*new_r21))+((new_r01*x936))+((sj5*x932)));
evalcond[14]=((-1.0)+((cj5*new_r22))+((sj5*x935))+((sj5*x934)));
evalcond[15]=((((-1.0)*cj5*x934))+((new_r22*sj5))+(((-1.0)*cj5*new_r12*x933)));
evalcond[16]=(sj6+(((-1.0)*cj5*x932))+(((-1.0)*new_r01*x938))+((new_r21*sj5)));
evalcond[17]=(((new_r20*sj5))+(((-1.0)*cj5*new_r10*x933))+(((-1.0)*new_r00*x938))+(((-1.0)*cj6)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x939=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x939.valid){
continue;
}
CheckValue<IkReal> x940 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x940.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x939.value)))+(x940.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[18];
IkReal x941=IKcos(j4);
IkReal x942=IKsin(j4);
IkReal x943=((1.0)*sj5);
IkReal x944=(cj5*cj6);
IkReal x945=(cj5*sj6);
IkReal x946=(new_r11*x942);
IkReal x947=((1.0)*x942);
IkReal x948=(new_r02*x941);
IkReal x949=(new_r12*x942);
IkReal x950=(sj5*x941);
IkReal x951=(new_r10*x942);
IkReal x952=((1.0)*cj5*x941);
evalcond[0]=((((-1.0)*x941*x943))+new_r02);
evalcond[1]=((((-1.0)*x942*x943))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x947))+((new_r12*x941)));
evalcond[3]=(sj6+((new_r10*x941))+(((-1.0)*new_r00*x947)));
evalcond[4]=(cj6+((new_r11*x941))+(((-1.0)*new_r01*x947)));
evalcond[5]=(((sj6*x941))+((x942*x944))+new_r10);
evalcond[6]=((((-1.0)*x943))+x948+x949);
evalcond[7]=(((new_r00*x941))+x951+x944);
evalcond[8]=(((x941*x944))+new_r00+(((-1.0)*sj6*x947)));
evalcond[9]=((((-1.0)*x945*x947))+((cj6*x941))+new_r11);
evalcond[10]=(((new_r01*x941))+(((-1.0)*x945))+x946);
evalcond[11]=((((-1.0)*cj6*x947))+(((-1.0)*x941*x945))+new_r01);
evalcond[12]=(((new_r00*x950))+((cj5*new_r20))+((sj5*x951)));
evalcond[13]=(((new_r01*x950))+((cj5*new_r21))+((sj5*x946)));
evalcond[14]=((-1.0)+((cj5*new_r22))+((sj5*x949))+((sj5*x948)));
evalcond[15]=((((-1.0)*cj5*x948))+((new_r22*sj5))+(((-1.0)*cj5*new_r12*x947)));
evalcond[16]=(sj6+(((-1.0)*cj5*x946))+(((-1.0)*new_r01*x952))+((new_r21*sj5)));
evalcond[17]=(((new_r20*sj5))+(((-1.0)*new_r00*x952))+(((-1.0)*cj5*new_r10*x947))+(((-1.0)*cj6)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x953=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x953.valid){
continue;
}
CheckValue<IkReal> x954 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x954.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x953.value)))+(x954.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x955=IKcos(j4);
IkReal x956=IKsin(j4);
IkReal x957=((1.0)*cj5);
IkReal x958=(new_r02*x955);
IkReal x959=(sj5*x955);
IkReal x960=(sj5*x956);
IkReal x961=(new_r12*x956);
evalcond[0]=((((-1.0)*x959))+new_r02);
evalcond[1]=((((-1.0)*x960))+new_r12);
evalcond[2]=(((new_r12*x955))+(((-1.0)*new_r02*x956)));
evalcond[3]=((((-1.0)*sj5))+x961+x958);
evalcond[4]=(((new_r00*x959))+((cj5*new_r20))+((new_r10*x960)));
evalcond[5]=(((new_r11*x960))+((new_r01*x959))+((cj5*new_r21)));
evalcond[6]=((-1.0)+((cj5*new_r22))+((sj5*x958))+((new_r12*x960)));
evalcond[7]=(((new_r22*sj5))+(((-1.0)*x957*x958))+(((-1.0)*x957*x961)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[3];
j6eval[0]=sj5;
j6eval[1]=IKsign(sj5);
j6eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
j6eval[0]=sj5;
j6eval[1]=cj4;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
j6eval[0]=sj5;
j6eval[1]=cj5;
j6eval[2]=sj4;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x962=((1.0)*new_r10);
if( IKabs((((new_r00*sj4))+(((-1.0)*cj4*x962)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x962)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*sj4))+(((-1.0)*cj4*x962))))+IKsqr(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x962))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((new_r00*sj4))+(((-1.0)*cj4*x962))), ((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x962))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x963=IKcos(j6);
IkReal x964=IKsin(j6);
IkReal x965=((1.0)*sj4);
IkReal x966=(cj4*x963);
IkReal x967=(cj4*x964);
IkReal x968=(x964*x965);
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x963);
evalcond[1]=(((cj4*new_r10))+(((-1.0)*new_r00*x965))+x964);
evalcond[2]=(((cj4*new_r11))+(((-1.0)*new_r01*x965))+x963);
evalcond[3]=(((sj4*x963))+new_r10+x967);
evalcond[4]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x964)));
evalcond[5]=(new_r00+x966+(((-1.0)*x968)));
evalcond[6]=(new_r11+x966+(((-1.0)*x968)));
evalcond[7]=((((-1.0)*x963*x965))+(((-1.0)*x967))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x969=((1.0)*new_r11);
if( IKabs(((((-1.0)*cj4*new_r10))+(((-1.0)*sj4*x969)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r10*sj4))+(((-1.0)*cj4*x969)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*new_r10))+(((-1.0)*sj4*x969))))+IKsqr((((new_r10*sj4))+(((-1.0)*cj4*x969))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*cj4*new_r10))+(((-1.0)*sj4*x969))), (((new_r10*sj4))+(((-1.0)*cj4*x969))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x970=IKsin(j6);
IkReal x971=IKcos(j6);
IkReal x972=((1.0)*sj4);
IkReal x973=(cj4*x970);
IkReal x974=((1.0)*x971);
IkReal x975=(x971*x972);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x970);
evalcond[1]=(((cj4*new_r10))+(((-1.0)*new_r00*x972))+x970);
evalcond[2]=(((cj4*new_r11))+(((-1.0)*new_r01*x972))+x971);
evalcond[3]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x974)));
evalcond[4]=(((cj4*x971))+((sj4*x970))+new_r11);
evalcond[5]=(new_r10+x973+(((-1.0)*x975)));
evalcond[6]=(new_r01+x973+(((-1.0)*x975)));
evalcond[7]=((((-1.0)*x970*x972))+new_r00+(((-1.0)*cj4*x974)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x976=IKsin(j6);
IkReal x977=IKcos(j6);
IkReal x978=((1.0)*sj4);
IkReal x979=((1.0)*x977);
evalcond[0]=(new_r21+x976);
evalcond[1]=(new_r20+(((-1.0)*x979)));
evalcond[2]=(((cj4*x976))+new_r10);
evalcond[3]=(((cj4*x977))+new_r11);
evalcond[4]=((((-1.0)*x976*x978))+new_r00);
evalcond[5]=((((-1.0)*new_r12*x979))+new_r01);
evalcond[6]=(((cj4*new_r10))+(((-1.0)*new_r00*x978))+x976);
evalcond[7]=(((cj4*new_r11))+(((-1.0)*new_r01*x978))+x977);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x980=IKsin(j6);
IkReal x981=IKcos(j6);
IkReal x982=((1.0)*sj4);
evalcond[0]=(new_r20+x981);
evalcond[1]=((((-1.0)*x980))+new_r21);
evalcond[2]=(((cj4*x980))+new_r10);
evalcond[3]=(((cj4*x981))+new_r11);
evalcond[4]=(new_r01+((new_r12*x981)));
evalcond[5]=((((-1.0)*x980*x982))+new_r00);
evalcond[6]=(((cj4*new_r10))+(((-1.0)*new_r00*x982))+x980);
evalcond[7]=(((cj4*new_r11))+(((-1.0)*new_r01*x982))+x981);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x983=IKsin(j6);
IkReal x984=IKcos(j6);
IkReal x985=((1.0)*cj5);
IkReal x986=((1.0)*x984);
evalcond[0]=(new_r10+x983);
evalcond[1]=(new_r11+x984);
evalcond[2]=(((new_r02*x983))+new_r21);
evalcond[3]=(((cj5*x984))+new_r00);
evalcond[4]=((((-1.0)*new_r02*x986))+new_r20);
evalcond[5]=(new_r01+(((-1.0)*x983*x985)));
evalcond[6]=((((-1.0)*new_r01*x985))+((new_r21*sj5))+x983);
evalcond[7]=((((-1.0)*x986))+((new_r20*sj5))+(((-1.0)*new_r00*x985)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r10, new_r11);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x987=IKcos(j6);
IkReal x988=IKsin(j6);
IkReal x989=((1.0)*x988);
evalcond[0]=(((new_r02*x987))+new_r20);
evalcond[1]=((((-1.0)*new_r10))+x988);
evalcond[2]=((((-1.0)*new_r11))+x987);
evalcond[3]=((((-1.0)*new_r02*x989))+new_r21);
evalcond[4]=(((cj5*x987))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*new_r01))+(((-1.0)*cj5*x989)));
evalcond[6]=(((cj5*new_r01))+((new_r21*sj5))+x988);
evalcond[7]=(((new_r20*sj5))+(((-1.0)*x987))+((cj5*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r00, new_r01);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x990=IKsin(j6);
IkReal x991=IKcos(j6);
IkReal x992=((1.0)*cj5);
IkReal x993=((1.0)*x991);
evalcond[0]=(((new_r12*x990))+new_r21);
evalcond[1]=((((-1.0)*new_r00))+x990);
evalcond[2]=((((-1.0)*new_r01))+x991);
evalcond[3]=(((cj5*x991))+new_r10);
evalcond[4]=((((-1.0)*new_r12*x993))+new_r20);
evalcond[5]=((((-1.0)*x990*x992))+new_r11);
evalcond[6]=((((-1.0)*new_r11*x992))+((new_r21*sj5))+x990);
evalcond[7]=((((-1.0)*new_r10*x992))+((new_r20*sj5))+(((-1.0)*x993)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x994=IKcos(j6);
IkReal x995=IKsin(j6);
IkReal x996=((1.0)*x995);
evalcond[0]=(new_r00+x995);
evalcond[1]=(new_r01+x994);
evalcond[2]=(((new_r12*x994))+new_r20);
evalcond[3]=((((-1.0)*new_r12*x996))+new_r21);
evalcond[4]=(((cj5*x994))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*cj5*x996))+(((-1.0)*new_r11)));
evalcond[6]=(((cj5*new_r11))+((new_r21*sj5))+x995);
evalcond[7]=((((-1.0)*x994))+((new_r20*sj5))+((cj5*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j6eval[0]=1.0;
if( IKabs(j6eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j6]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=-1.0;
op[1]=0;
op[2]=1.0;
polyroots2(op,zeror,numroots);
IkReal j6array[2], cj6array[2], sj6array[2], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[2]={true,true};
_nj6 = 2;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x998=IKPowWithIntegerCheck(sj5,-1);
if(!x998.valid){
continue;
}
IkReal x997=x998.value;
CheckValue<IkReal> x999=IKPowWithIntegerCheck(cj5,-1);
if(!x999.valid){
continue;
}
CheckValue<IkReal> x1000=IKPowWithIntegerCheck(sj4,-1);
if(!x1000.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x997)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x997*(x999.value)*(x1000.value)*((((cj4*new_r21))+(((-1.0)*new_r10*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x997))+IKsqr((x997*(x999.value)*(x1000.value)*((((cj4*new_r21))+(((-1.0)*new_r10*sj5))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21*x997), (x997*(x999.value)*(x1000.value)*((((cj4*new_r21))+(((-1.0)*new_r10*sj5))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x1001=IKsin(j6);
IkReal x1002=IKcos(j6);
IkReal x1003=((1.0)*sj4);
IkReal x1004=(cj4*cj5);
IkReal x1005=(cj5*x1001);
IkReal x1006=((1.0)*x1002);
IkReal x1007=(cj5*x1002);
evalcond[0]=(((sj5*x1001))+new_r21);
evalcond[1]=(new_r20+(((-1.0)*sj5*x1006)));
evalcond[2]=(x1001+((cj4*new_r10))+(((-1.0)*new_r00*x1003)));
evalcond[3]=(x1002+((cj4*new_r11))+(((-1.0)*new_r01*x1003)));
evalcond[4]=(x1007+((cj4*new_r00))+((new_r10*sj4)));
evalcond[5]=(((sj4*x1007))+((cj4*x1001))+new_r10);
evalcond[6]=((((-1.0)*x1005))+((cj4*new_r01))+((new_r11*sj4)));
evalcond[7]=((((-1.0)*x1001*x1003))+new_r00+((x1002*x1004)));
evalcond[8]=(((cj4*x1002))+new_r11+(((-1.0)*x1003*x1005)));
evalcond[9]=((((-1.0)*x1001*x1004))+(((-1.0)*x1002*x1003))+new_r01);
evalcond[10]=((((-1.0)*new_r01*x1004))+x1001+(((-1.0)*cj5*new_r11*x1003))+((new_r21*sj5)));
evalcond[11]=((((-1.0)*cj5*new_r10*x1003))+((new_r20*sj5))+(((-1.0)*x1006))+(((-1.0)*new_r00*x1004)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x1009=IKPowWithIntegerCheck(sj5,-1);
if(!x1009.valid){
continue;
}
IkReal x1008=x1009.value;
CheckValue<IkReal> x1010=IKPowWithIntegerCheck(cj4,-1);
if(!x1010.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x1008)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1008*(x1010.value)*(((((-1.0)*cj5*new_r21*sj4))+(((-1.0)*new_r11*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x1008))+IKsqr((x1008*(x1010.value)*(((((-1.0)*cj5*new_r21*sj4))+(((-1.0)*new_r11*sj5))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21*x1008), (x1008*(x1010.value)*(((((-1.0)*cj5*new_r21*sj4))+(((-1.0)*new_r11*sj5))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x1011=IKsin(j6);
IkReal x1012=IKcos(j6);
IkReal x1013=((1.0)*sj4);
IkReal x1014=(cj4*cj5);
IkReal x1015=(cj5*x1011);
IkReal x1016=((1.0)*x1012);
IkReal x1017=(cj5*x1012);
evalcond[0]=(((sj5*x1011))+new_r21);
evalcond[1]=((((-1.0)*sj5*x1016))+new_r20);
evalcond[2]=(x1011+((cj4*new_r10))+(((-1.0)*new_r00*x1013)));
evalcond[3]=(x1012+((cj4*new_r11))+(((-1.0)*new_r01*x1013)));
evalcond[4]=(x1017+((cj4*new_r00))+((new_r10*sj4)));
evalcond[5]=(((sj4*x1017))+((cj4*x1011))+new_r10);
evalcond[6]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x1015)));
evalcond[7]=((((-1.0)*x1011*x1013))+((x1012*x1014))+new_r00);
evalcond[8]=(((cj4*x1012))+(((-1.0)*x1013*x1015))+new_r11);
evalcond[9]=((((-1.0)*x1012*x1013))+(((-1.0)*x1011*x1014))+new_r01);
evalcond[10]=((((-1.0)*cj5*new_r11*x1013))+x1011+((new_r21*sj5))+(((-1.0)*new_r01*x1014)));
evalcond[11]=(((new_r20*sj5))+(((-1.0)*x1016))+(((-1.0)*cj5*new_r10*x1013))+(((-1.0)*new_r00*x1014)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x1018 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),IkReal(new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x1018.valid){
continue;
}
CheckValue<IkReal> x1019=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x1019.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1018.value)+(((1.5707963267949)*(x1019.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x1020=IKsin(j6);
IkReal x1021=IKcos(j6);
IkReal x1022=((1.0)*sj4);
IkReal x1023=(cj4*cj5);
IkReal x1024=(cj5*x1020);
IkReal x1025=((1.0)*x1021);
IkReal x1026=(cj5*x1021);
evalcond[0]=(new_r21+((sj5*x1020)));
evalcond[1]=(new_r20+(((-1.0)*sj5*x1025)));
evalcond[2]=((((-1.0)*new_r00*x1022))+x1020+((cj4*new_r10)));
evalcond[3]=(x1021+((cj4*new_r11))+(((-1.0)*new_r01*x1022)));
evalcond[4]=(x1026+((cj4*new_r00))+((new_r10*sj4)));
evalcond[5]=(((sj4*x1026))+((cj4*x1020))+new_r10);
evalcond[6]=(((cj4*new_r01))+(((-1.0)*x1024))+((new_r11*sj4)));
evalcond[7]=((((-1.0)*x1020*x1022))+((x1021*x1023))+new_r00);
evalcond[8]=((((-1.0)*x1022*x1024))+((cj4*x1021))+new_r11);
evalcond[9]=((((-1.0)*x1021*x1022))+new_r01+(((-1.0)*x1020*x1023)));
evalcond[10]=(x1020+(((-1.0)*cj5*new_r11*x1022))+(((-1.0)*new_r01*x1023))+((new_r21*sj5)));
evalcond[11]=((((-1.0)*new_r00*x1023))+((new_r20*sj5))+(((-1.0)*cj5*new_r10*x1022))+(((-1.0)*x1025)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - iiwa (a915a9ad3f35f49dacb710745993d319)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
